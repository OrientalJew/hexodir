---
title: 正则表达式
date: 2018-07-27 
tags: 
- 正则表达式
categories:
- Python
---

<!-- toc -->

#### 匹配字符

> 1、"."匹配\n之外的任意一个字符；

> 2、\d匹配数字，即0-9；

> 3、\D匹配非数字；

> 4、\s 匹配空白字符，即空格、tab键和回车；

> 5、\S匹配非空白字符；

> 6、\w匹配单词字符，即a-z，A-Z，0-9、下划线_
<!--more--> 
> 7、\W匹配非单词字符；

> 8、[] 表示某一位置上的字符可以使用的有限集合，如1[123abc]3表示第二位的可以是123abc；
	表示范围是可以使用"-"，[0-9a-z]
	\d == [0-9]
	\D == [^0-9]
	\w == [a-zA-Z0-9_]
	\W == [^a-zA-Z0-9_]

> 9、[ ^ ]表示某一位置上的字符只要不是集合中的字符都可以，如[^123abc],只要该位上的字符不是123abc即可；


#### 匹配数量

> 1、*  表示前一个字符可以出现0次或者多次；

> 2、+ 表示前一个字符可以出现1次或者多次，至少出现1次；

> 3、？表示前一个字符可以出现1次或者0次；

> 4、{m} 表示前一个字符需要出现m次；

> 5、{m，} 表示前一个字符需要出现至少m次；

> 6、{m，n} 表示前一个字符可以出现m到n次；


#### 匹配字符边界

> 边界匹配符可以一次匹配多个字符，而无需添加括号；
```	
比如 ^abc\d{3}abc$ 表示匹配abc开头和结尾，中间3个数字；
一般匹配多个字符是需要添加括号的：^abc(df){3}abc$，表示匹配abc开头和结尾，中间3次df；	
```
1、^ 表示后面的第一个匹配规则作为匹配的开头；

> 2、$ 表示前面的最后一个匹配规则作为匹配的结尾；

> 3、\b 匹配单词边界，相当于字符串在此处要不是开头结尾，要不就必须是一个空格，这样才处于边界；

```
注意，\b表示的是边界问题，不匹配字符；如果\b不是处于匹配规则的结尾或者开头，则需要注意匹配规则中必须额外匹配空格。

	比如：\babc\d{2}abc\b 表示匹配abc作为单词左右边界，中间两个数字；

    ^hh\babc 目的是匹配hh开头，abc为左边界的字符串，即 hh abc
    但实际上还需要匹配中间的空格，所以规则必须为 ^hh\s\babc

注：\b 是特殊字符，退格键，所以不能直接写在正则中，必须转义"\\b"或者使用原始字符串r"\b"
```	
> 4、\B 表示匹配非单词边界，即匹配的字符串不能处于边界，必须出现单词。
```
	比如，\Babc\B 表示abc的左右不能处于开头或结尾，也不能有空格。
```

#### 匹配分组

> 1、| 表示匹配左右任意一个匹配规则
```
	比如，^hi\d{2}|^hello\w{2} 表示匹配hi开头后面跟两个数字或者hello开头，后面跟两个字母。

	匹配0-100之间的数字："[1-9]?\d?$|100$" 或者 "[1-9]\d?$|0$|100$"
```
> 2、(ab) 匹配分组，括号内的字符串可以作为一个分组；
```	
作用1：可以用来表示一串字符为一个整体作为表达式中的一部分，比如(abc){2} 表示匹配两次abc；

作用2：分组配合group()可以用来提取匹配到的字符串中的数据；

    比如，^hsh(hi)\d(nihao)\d 其中的分组为(hi)和(nihao)，通过group(index)可以进行提取；
	
	result = re.match(r"^hsh(hi)\d(nihao)\d","hshhi1nihao2")
	result.group(1) #hi
	result.group(2) #nihao

	匹配邮箱，并提取账号：
	pattern = r"(\w+)@(163|126|gmail|qq)\.(com|cn|net)$"
	result = re.match(p , "itcast@qq.com")
	result.group(1)
	
	提取字符串和电话号码，并且不要中间的空格：this is number 234-234-234
	result = re.match(r"(.+?)\s(\d+-\d+-\d+)","this is number 234-234-234")
	result.group(1) == this is number
	result.group(2) == 234-234-234
```		
> 3、\num 按序引用前面匹配的分组，主要作用在html等对称数据的匹配上；

```
    比如，匹配<html><h1>hsh</h1></html>，这种类型的数据，必须使用：
    
	<(.+)><(.+)>.+</\2></\1> 其中，\1和\2表示匹配到的第1和第2分组；	
```
> 4、 为分组取别名；
```	
    (?P<name>) 引用通过 (?P=name)

	<(.+)><(.+)>.+</\2></\1> 可以改为：<(?P<k1>.+)><(?P<k2>.+)>.+</(?P=k2)></(?P=k1)>

```

#### 贪婪与非贪婪


> \* 或+ 默认是开启贪婪模式的，也就是说，它们会尽可能的匹配多的字符；
```
	result = re.match(r"(.*)(\d+-\d+-\d+)(\d+-\d+-\d+)","this is number 234-234-234")
	result.group(1) == this is number 23
	result.group(2) == 4-234-234
    为满足第一个分组的贪婪，会尽可能的多匹配字符，而第二个分组虽然也是贪婪的，但是优先级较小；
```
> 非贪婪：通过在\*和+后面添加?，可以关闭贪婪模式

```
*或+后面添加?关闭贪婪模式，非贪婪模式下，会尽可能的少匹配字符串；
	result = re.match(r"(.*?)(\d+-\d+-\d+)(\d+-\d+-\d+)","this is number 234-234-234")
	result.group(1) == "this is number "
	result.group(2) == '234-234-234'

非贪婪模式下，虽然会尽可能的少匹配字符串，但是，前提是在满足其他的匹配模式下；
	re.match(r"aa(\d+?)ddd","aa1234ddd").group(1)
	结果为1234，虽然分组设置为非贪婪的，但是为了满足匹配模式中的"ddd"，1234被完全匹配进来；
```
