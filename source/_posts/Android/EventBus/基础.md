---
title: EventBus基础
date: 2018-08-03
tags:
- 基础
categories:
- EventBus
---

<!-- toc -->

#### 什么是EventBus

**EventBus是一个使用"观察者模式"的、松耦合的开源框架，能够帮助我们简化代码、松依赖、加速开发。**

![image](/images/eventbus.png)

#### 源码分析

##### EventBus实例创建
使用懒汉单例创建：
```
  public static EventBus getDefault() {
        if (defaultInstance == null) {
            synchronized (EventBus.class) {
                if (defaultInstance == null) {
                    defaultInstance = new EventBus();
                }
            }
        }
        return defaultInstance;
    }
```
构造方法：
```
    EventBus(EventBusBuilder builder) {
        // key:订阅的事件,value:订阅这个事件的所有订阅者集合
        // private final Map<Class<?>, CopyOnWriteArrayList<Subscription>> subscriptionsByEventType;
        subscriptionsByEventType = new HashMap<>();

        // key:订阅者对象(Activity/Fragment),value:这个订阅者订阅的事件集合(上面集合的key)
        // private final Map<Object, List<Class<?>>> typesBySubscriber;
        typesBySubscriber = new HashMap<>();

        // 粘性事件 key:粘性事件的class对象, value:事件对象
        // private final Map<Class<?>, Object> stickyEvents;
        stickyEvents = new ConcurrentHashMap<>();

        // 事件主线程处理(继承自Handler)
        mainThreadPoster = new HandlerPoster(this, Looper.getMainLooper(), 10);

        // 事件Background同步处理(后台线程)
        // 采用Executors.newCachedThreadPool()来后台处理
        backgroundPoster = new BackgroundPoster(this);

        // 事件异步线程处理(和BackgroundPoster一样，也用Executors.newCachedThreadPool
        // 处理异步事件，但是多个事件是异步的)
        asyncPoster = new AsyncPoster(this);

        indexCount = builder.subscriberInfoIndexes != null ? builder.subscriberInfoIndexes.size() : 0;

        //订阅者订阅函数的信息存储和查找类
        subscriberMethodFinder = new SubscriberMethodFinder(builder.subscriberInfoIndexes,
                builder.strictMethodVerification, builder.ignoreGeneratedIndex);
        logSubscriberExceptions = builder.logSubscriberExceptions;
        logNoSubscriberMessages = builder.logNoSubscriberMessages;
        sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;
        sendNoSubscriberEvent = builder.sendNoSubscriberEvent;
        throwSubscriberException = builder.throwSubscriberException;

        //是否支持事件继承(存在继承关系的事件，父类是否也要受到通知)
        eventInheritance = builder.eventInheritance;
        executorService = builder.executorService;
    }
```
>  CopyOnWriteArrayList解决了多线程并发的问题，在添加时，会拷贝原数组的到新的数组中，在添加
时，在新的数组中进行操作，并且多线程使用锁机制，而读取时，没有加锁(根据数组是否处于添加状态，可能
读取到的是旧数组，也可能是新数组，所以**读取实时性差**)，适合读多写少的场景，不适合数据量巨大的
场景(拷贝太耗性能).

> ConcurrentHashMap是高性能的并发HashMap，相比于HashTable更加高效。不同于HashTable全局
只有一把锁的情况(多线程并发的情景下，抢不到锁的线程需要等待其他线程释放锁，会先被挂起)，
ConcurrentHashMap采用的是分段锁(所有数据根据Hash运算分到不同段，一个段分配一把锁，这样在多线
程并发的情景下，不同线程访问到不同的数据段时，不需要等待锁的释放，减少不必要的等待和上下文切换开
销)。

##### 注册

```
  public void register(Object subscriber) {
      // 首先获得订阅者的class对象
      Class<?> subscriberClass = subscriber.getClass();
      // 通过subscriberMethodFinder来找到订阅者订阅了哪些事件.返回一个SubscriberMethod对象的List,SubscriberMethod
      // 里包含了这个方法的Method对象,以及将来响应订阅是在哪个线程的ThreadMode,订阅的事件类型eventType,订阅的优
      // 先级priority,是否接收粘性sticky事件的boolean值.
      List<SubscriberMethod> subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);
      synchronized (this) {
          for (SubscriberMethod subscriberMethod : subscriberMethods) {
              //订阅
              subscribe(subscriber, subscriberMethod);
          }
      }
  }
```

##### findSubscriberMethods

该方法用来查找到订阅者订阅的事件(订阅方法的第一个参数类型)、线程、是否sticky、优先级等信息封装到
SubscriberMethod对象中；

```
List<SubscriberMethod> findSubscriberMethods(Class<?> subscriberClass) {
    // 先从METHOD_CACHE取看是否有缓存,key:保存订阅者的类名,value:保存类中订阅的方法数据
    List<SubscriberMethod> subscriberMethods = METHOD_CACHE.get(subscriberClass);
    if (subscriberMethods != null) {
        return subscriberMethods;
    }

    // 是否忽略注解器生成的MyEventBusIndex类(强制使用注解的方式)
    if (ignoreGeneratedIndex) {
        // 利用反射来读取订阅者中的订阅方法信息
        subscriberMethods = findUsingReflection(subscriberClass);
    } else {
        // 从注解器生成的MyEventBusIndex类中获得订阅类的订阅方法信息
        // 注解生成器需要额外的配置在gradle中
        subscriberMethods = findUsingInfo(subscriberClass);
    }
    if (subscriberMethods.isEmpty()) {
        throw new EventBusException("Subscriber " + subscriberClass
                + " and its super classes have no public methods with the @Subscribe annotation");
    } else {
        // 保存进METHOD_CACHE缓存
        METHOD_CACHE.put(subscriberClass, subscriberMethods);
        return subscriberMethods;
    }
}
```
// 收纳注解
