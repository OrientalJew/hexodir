<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">






  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-center-simple.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="拦截器每一个Call请求都需要经过一些列的拦截器处理，Ok通过这些拦截器实现了对Call请求的重试、重定向、缓存、设置请求头、压缩，甚至是最终对服务端的请求和接收返回数据也都是在拦截器中进行的；">
<meta name="keywords" content="OkHttp">
<meta property="og:type" content="article">
<meta property="og:title" content="OkHttp源码分析(二)">
<meta property="og:url" content="http://yoursite.com/2018/08/16/Android/OkHttp/OkHttp源码分析二/index.html">
<meta property="og:site_name" content="HSH&#39;s Blogs">
<meta property="og:description" content="拦截器每一个Call请求都需要经过一些列的拦截器处理，Ok通过这些拦截器实现了对Call请求的重试、重定向、缓存、设置请求头、压缩，甚至是最终对服务端的请求和接收返回数据也都是在拦截器中进行的；">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/images/connectinterceptor转换关系.png">
<meta property="og:image" content="http://yoursite.com/images/StreamAllocation与Connection和httpcodec关系.png">
<meta property="og:image" content="http://yoursite.com/images/StreamAllocation与RealConnection.png">
<meta property="og:updated_time" content="2018-08-31T02:52:06.207Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="OkHttp源码分析(二)">
<meta name="twitter:description" content="拦截器每一个Call请求都需要经过一些列的拦截器处理，Ok通过这些拦截器实现了对Call请求的重试、重定向、缓存、设置请求头、压缩，甚至是最终对服务端的请求和接收返回数据也都是在拦截器中进行的；">
<meta name="twitter:image" content="http://yoursite.com/images/connectinterceptor转换关系.png">






  <link rel="canonical" href="http://yoursite.com/2018/08/16/Android/OkHttp/OkHttp源码分析二/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>OkHttp源码分析(二) | HSH's Blogs</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">HSH's Blogs</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />Tags</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />Categories</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    
  
  
  
    
      
    
    <a href="https://github.com/OrientalJew" class="github-corner" target="_blank" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
    
      </a>
    



    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/16/Android/OkHttp/OkHttp源码分析二/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="黄声焕">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HSH's Blogs">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">OkHttp源码分析(二)
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-08-16 00:00:00" itemprop="dateCreated datePublished" datetime="2018-08-16T00:00:00+08:00">2018-08-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-08-31 10:52:06" itemprop="dateModified" datetime="2018-08-31T10:52:06+08:00">2018-08-31</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/框架源码/" itemprop="url" rel="index"><span itemprop="name">框架源码</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon"
            >
            <i class="fa fa-eye"></i>
             Views:  
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <!-- toc -->
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>每一个Call请求都需要经过一些列的拦截器处理，Ok通过这些拦截器实现了对Call请求的重试、重定向、缓存<br>、设置请求头、压缩，甚至是最终对服务端的请求和接收返回数据也都是在拦截器中进行的；</p>
<a id="more"></a>
<p>RealCall.getResponseWithInterceptorChain<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Response getResponseWithInterceptorChain() throws IOException &#123;</span><br><span class="line">  // Build a full stack of interceptors.</span><br><span class="line">  List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">  // 添加我们通过addInterceptor添加的应用拦截器</span><br><span class="line">  interceptors.addAll(client.interceptors());</span><br><span class="line">  // 添加失败重试和请求重定向拦截器</span><br><span class="line">  interceptors.add(retryAndFollowUpInterceptor);</span><br><span class="line">  // 添加请求头信息、对接收内容进行gzip压缩</span><br><span class="line">  interceptors.add(new BridgeInterceptor(client.cookieJar()));</span><br><span class="line">  // 对请求进行缓存管理</span><br><span class="line">  interceptors.add(new CacheInterceptor(client.internalCache()));</span><br><span class="line">  // 从连接池中获取一个有效的连接(可能是重用的，也可能是新建的)</span><br><span class="line">  interceptors.add(new ConnectInterceptor(client));</span><br><span class="line">  // 如果不是通过WebSocket协议连接的，则还会添加网络拦截器，即我们通过addNetworkInterceptor</span><br><span class="line">  // 添加的拦截器</span><br><span class="line">  if (!forWebSocket) &#123;</span><br><span class="line">    interceptors.addAll(client.networkInterceptors());</span><br><span class="line">  &#125;</span><br><span class="line">  // 负责向服务器发起访问，并拿到最原始的返回数据往回传</span><br><span class="line">  interceptors.add(new CallServerInterceptor(forWebSocket));</span><br><span class="line"></span><br><span class="line">  // 创建拦截器链，用来处理每一个请求</span><br><span class="line">  Interceptor.Chain chain = new RealInterceptorChain(</span><br><span class="line">      interceptors, null, null, null, 0, originalRequest);</span><br><span class="line">  // 开始执行调用链</span><br><span class="line">  return chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>请求的发起和接收，都是在拦截器中进行的，不管是异步还是同步请求，都会调用该方法，来启动拦截器链；</p>
<h4 id="RealInterceptorChain"><a href="#RealInterceptorChain" class="headerlink" title="RealInterceptorChain"></a>RealInterceptorChain</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">public final class RealInterceptorChain implements Interceptor.Chain &#123;</span><br><span class="line">  // 当前Call请求对应的所有拦截器；</span><br><span class="line">  private final List&lt;Interceptor&gt; interceptors;</span><br><span class="line"></span><br><span class="line">  // 用来从连接池找到合适的连接(新建，重用)，创建数据流对象，用来进行数据通信</span><br><span class="line">  private final StreamAllocation streamAllocation;</span><br><span class="line"></span><br><span class="line">  // okhttp数据流对象,由StreamAllocation创建，Ok与服务端的通信就是通过这个对象来实现的</span><br><span class="line">  // (Socket通信)</span><br><span class="line">  private final HttpCodec httpCodec;</span><br><span class="line"></span><br><span class="line">  // 与服务端的socket的链路，用来实现三次握手，建立通信</span><br><span class="line">  private final RealConnection connection;</span><br><span class="line"></span><br><span class="line">  // 表示当前正在执行的拦截器索引</span><br><span class="line">  private final int index;</span><br><span class="line"></span><br><span class="line">  // 本次Http请求</span><br><span class="line">  private final Request request;</span><br><span class="line"></span><br><span class="line">  // 用来标记同一个拦截器被执行的次数，同一个拦截器不能够被调用两次</span><br><span class="line">  private int calls;</span><br><span class="line"></span><br><span class="line">  // 第一次创建在RealCall中进行，此时只是提供了拦截器集合和Request，其他都是null</span><br><span class="line">  // 这些参数在后面的拦截器流程中会被逐个进行创建</span><br><span class="line">  public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, StreamAllocation streamAllocation,</span><br><span class="line">      HttpCodec httpCodec, RealConnection connection, int index, Request request) &#123;</span><br><span class="line">    this.interceptors = interceptors;</span><br><span class="line">    this.connection = connection;</span><br><span class="line">    this.streamAllocation = streamAllocation;</span><br><span class="line">    this.httpCodec = httpCodec;</span><br><span class="line">    this.index = index;</span><br><span class="line">    this.request = request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Connection connection() &#123;</span><br><span class="line">    return connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public StreamAllocation streamAllocation() &#123;</span><br><span class="line">    return streamAllocation;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public HttpCodec httpStream() &#123;</span><br><span class="line">    return httpCodec;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Request request() &#123;</span><br><span class="line">    return request;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 每一个拦截器的拦截流程，最终都是调用该方法用来推送下一个拦截器的执行</span><br><span class="line">  @Override public Response proceed(Request request) throws IOException &#123;</span><br><span class="line">    return proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // RealInterceptorChain核心，整个拦截器链的调用是通过这个方法推动的</span><br><span class="line">  public Response proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">      RealConnection connection) throws IOException &#123;</span><br><span class="line">    if (index &gt;= interceptors.size()) throw new AssertionError();</span><br><span class="line">    // 记录当前拦截器被调用的次数</span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    // 判断当前连接的端口和host是否支持该url</span><br><span class="line">    // If we already have a stream, confirm that the incoming request will use it.</span><br><span class="line">    if (this.httpCodec != null &amp;&amp; !this.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must retain the same host and port&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果同一个拦截器实例被调用超过1次，则抛出异常</span><br><span class="line">    // If we already have a stream, confirm that this is the only call to chain.proceed().</span><br><span class="line">    if (this.httpCodec != null &amp;&amp; calls &gt; 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptors.get(index - 1)</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 为当前拦截器创建一个RealInterceptorChain，将Http请求所需的所有信息都包装进去</span><br><span class="line">    // Call the next interceptor in the chain.</span><br><span class="line">    RealInterceptorChain next = new RealInterceptorChain(</span><br><span class="line">        interceptors, streamAllocation, httpCodec, connection, index + 1, request);</span><br><span class="line"></span><br><span class="line">    // 拿到当前需要执行的拦截器</span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line"></span><br><span class="line">    // 执行拦截器的拦截方法</span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    // 检查当前拦截器是否在最后执行了Chain的proceed方法，来推动下一个拦截器的执行</span><br><span class="line">    // 调用了proceed方法，RealInterceptorChain的calls变量应该等于1</span><br><span class="line">    // Confirm that the next interceptor made its required call to chain.proceed().</span><br><span class="line">    if (httpCodec != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;network interceptor &quot; + interceptor</span><br><span class="line">          + &quot; must call proceed() exactly once&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检查每一个拦截器处理后返回的Response是否为null</span><br><span class="line">    // Confirm that the intercepted response isn&apos;t null.</span><br><span class="line">    if (response == null) &#123;</span><br><span class="line">      throw new NullPointerException(&quot;interceptor &quot; + interceptor + &quot; returned null&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RealInterceptorChain是Ok拦截器链，其中包含了Ok中所有的拦截器；</p>
<p>RealInterceptorChain贯穿了整个拦截链的始终，其中包含了Http请求需要的重要数据：request请求、<br>连接客户端(RealConnection)、以及连接和流(StreamAllocation)等；</p>
<p>每开启一个拦截器进行操作时，都会创建相应的RealInterceptorChain，用来将Http请求的数据封装，传<br>递给拦截器；</p>
<p>每一个拦截器的操作，都会通过RealInterceptorChain来获取其中需要的信息，并且最终会通过<br>RealInterceptorChain来推动，进入到下一个拦截器中进行拦截操作；</p>
<h4 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h4><p>RetryAndFollowUpInterceptor是Call请求流程中第一个系统拦截器，其起到的主要作用是实现Call<br>请求的失败重试和重定向；</p>
<p>1、成员变量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public final class RetryAndFollowUpInterceptor implements Interceptor &#123;</span><br><span class="line">  /**</span><br><span class="line">   * How many redirects and auth challenges should we attempt? Chrome follows 21 redirects; Firefox,</span><br><span class="line">   * curl, and wget follow 20; Safari follows 16; and HTTP/1.0 recommends 5.</span><br><span class="line">   */</span><br><span class="line">  // 最大的重定向和重试次数</span><br><span class="line">  private static final int MAX_FOLLOW_UPS = 20;</span><br><span class="line"></span><br><span class="line">  private final OkHttpClient client;</span><br><span class="line">  // 是否使用WebSocket协议</span><br><span class="line">  private final boolean forWebSocket;</span><br><span class="line"></span><br><span class="line">  // 用来从连接池找到合适的连接(新建，重用)，创建数据流对象，用来进行数据通信</span><br><span class="line">  private StreamAllocation streamAllocation;</span><br><span class="line"></span><br><span class="line">  // 打印日志用的调用栈的跟踪对象</span><br><span class="line">  private Object callStackTrace;</span><br><span class="line"></span><br><span class="line">  // 标记当前请求是否已经取消了</span><br><span class="line">  private volatile boolean canceled;</span><br></pre></td></tr></table></figure></p>
<p>2、cancel</p>
<p>我们可以通过Call的Cancel方法来取消当前正在执行的请求，则这个Cancel方法实际上就是调用<br>RetryAndFollowUpInterceptor的cancel方法；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public void cancel() &#123;</span><br><span class="line">  // 标记当前的请求状态为取消</span><br><span class="line">  canceled = true;</span><br><span class="line"></span><br><span class="line">  // 通过StreamAllocation关闭连接和数据流</span><br><span class="line">  StreamAllocation streamAllocation = this.streamAllocation;</span><br><span class="line">  if (streamAllocation != null) streamAllocation.cancel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>3、createAddress</p>
<p>通过请求的链接信息(HttpUrl)，构造出即将访问的服务器地址信息，包含了主机名，端口等，如果是通过<br>代理来请求的，还会包含代理的信息；如果是通过Https来请求的，则会为其创建SSL验证信息；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private Address createAddress(HttpUrl url) &#123;</span><br><span class="line">  SSLSocketFactory sslSocketFactory = null;</span><br><span class="line">  HostnameVerifier hostnameVerifier = null;</span><br><span class="line">  CertificatePinner certificatePinner = null;</span><br><span class="line">  // 如果是基于Https协议的链接，则为其创建相应的SSL协议证书验证</span><br><span class="line">  if (url.isHttps()) &#123;</span><br><span class="line">    sslSocketFactory = client.sslSocketFactory();</span><br><span class="line">    hostnameVerifier = client.hostnameVerifier();</span><br><span class="line">    certificatePinner = client.certificatePinner();</span><br><span class="line">  &#125;</span><br><span class="line">  // 构造一个代表服务端地址的信息类</span><br><span class="line">  return new Address(url.host(), url.port(), client.dns(), client.socketFactory(),</span><br><span class="line">      sslSocketFactory, hostnameVerifier, certificatePinner, client.proxyAuthenticator(),</span><br><span class="line">      client.proxy(), client.protocols(), client.connectionSpecs(), client.proxySelector());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、recover</p>
<p>当链接失败时，RetryAndFollowUpInterceptor拦截器会调用该方法尝试进行重连操作，如果请求带有<br>请求体，则只有在请求体已经被缓存的情况下，才能进行链接恢复。或者错误是在request请求被发送之前<br>出现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 参数2表示当前request请求是否已经发送了</span><br><span class="line">private boolean recover(IOException e, boolean requestSendStarted, Request userRequest) &#123;</span><br><span class="line">  // 向连接池抛出异常，并关闭Socket</span><br><span class="line">  streamAllocation.streamFailed(e);</span><br><span class="line"></span><br><span class="line">  // 如果我们在配置OK连接时已经设置失败不重连，则不进行重连</span><br><span class="line">  // The application layer has forbidden retries.</span><br><span class="line">  if (!client.retryOnConnectionFailure()) return false;</span><br><span class="line"></span><br><span class="line">  // 如果请求已经发送了，并且这个request的请求体是不能重复使用的请求体(比如请求体是不进行缓存的</span><br><span class="line">  // 请求)，则不进行重试</span><br><span class="line">  // We can&apos;t send the request body again.</span><br><span class="line">  if (requestSendStarted &amp;&amp; userRequest.body() instanceof UnrepeatableRequestBody) return false;</span><br><span class="line"></span><br><span class="line">  // 判断该异常是否是严重的IO异常，在该异常下是否能够连接重试</span><br><span class="line">  // This exception is fatal.</span><br><span class="line">  if (!isRecoverable(e, requestSendStarted)) return false;</span><br><span class="line"></span><br><span class="line">  // 是否还有路由可以尝试重连</span><br><span class="line">  // No more routes to attempt.</span><br><span class="line">  if (!streamAllocation.hasMoreRoutes()) return false;</span><br><span class="line"></span><br><span class="line">  // 可以进行连接重试，但是创建一个新的链接来重试路由选择器；</span><br><span class="line">  // For failure recovery, use the same route selector with a new connection.</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、isRecoverable</p>
<p>用来判断连接失败时，发出的异常是否是不可恢复的异常；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private boolean isRecoverable(IOException e, boolean requestSendStarted) &#123;</span><br><span class="line">  // If there was a protocol problem, don&apos;t recover.</span><br><span class="line">  // 协议异常，不恢复重试</span><br><span class="line">  if (e instanceof ProtocolException) &#123;</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果是中断异常，则检查是否是连接超时导致的，如果是并且存在下一个Route，则进行重试</span><br><span class="line">  // If there was an interruption don&apos;t recover, but if there was a timeout connecting to a route</span><br><span class="line">  // we should try the next route (if there is one).</span><br><span class="line">  if (e instanceof InterruptedIOException) &#123;</span><br><span class="line">    return e instanceof SocketTimeoutException &amp;&amp; !requestSendStarted;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 证书安全导致的SSL握手异常，不进行恢复</span><br><span class="line">  // Look for known client-side or negotiation errors that are unlikely to be fixed by trying</span><br><span class="line">  // again with a different route.</span><br><span class="line">  if (e instanceof SSLHandshakeException) &#123;</span><br><span class="line">    // If the problem was a CertificateException from the X509TrustManager,</span><br><span class="line">    // do not retry.</span><br><span class="line">    if (e.getCause() instanceof CertificateException) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 证书认证失败异常，不恢复</span><br><span class="line">  if (e instanceof SSLPeerUnverifiedException) &#123;</span><br><span class="line">    // e.g. a certificate pinning error.</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // An example of one we might want to retry with a different route is a problem connecting to a</span><br><span class="line">  // proxy and would manifest as a standard IOException. Unless it is one we know we should not</span><br><span class="line">  // retry, we return true and try a new route.</span><br><span class="line">  return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果异常是在我们连接到代理时发生的，并且是一个标准的IO异常，则判断是否是isRecoverable方法中指定要<br>拦截的异常，如果不是，则尝试一个新的路由；</p>
<p>6、followUpRequest</p>
<p>该方法用来检查服务端返回的response的状态，根据状态构造出新的包含安全认证的header，或者进行重定<br>向，或者处理为客户端连接超时(重新执行request请求)。如果接收该response之后不需要进行后续操作（<br>即直接返回），则返回null，否则返回更新后的request进行重新请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">private Request followUpRequest(Response userResponse) throws IOException &#123;</span><br><span class="line">  if (userResponse == null) throw new IllegalStateException();</span><br><span class="line">  Connection connection = streamAllocation.connection();</span><br><span class="line">  Route route = connection != null</span><br><span class="line">      ? connection.route()</span><br><span class="line">      : null;</span><br><span class="line"></span><br><span class="line">  // 获取服务端response对应的响应码</span><br><span class="line">  int responseCode = userResponse.code();</span><br><span class="line"></span><br><span class="line">  // 获取到原先request的请求方法类型</span><br><span class="line">  final String method = userResponse.request().method();</span><br><span class="line">  switch (responseCode) &#123;</span><br><span class="line">    // request需要重新认证</span><br><span class="line">    case HTTP_PROXY_AUTH:</span><br><span class="line">      Proxy selectedProxy = route != null</span><br><span class="line">          ? route.proxy()</span><br><span class="line">          : client.proxy();</span><br><span class="line">      if (selectedProxy.type() != Proxy.Type.HTTP) &#123;</span><br><span class="line">        throw new ProtocolException(&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return client.proxyAuthenticator().authenticate(route, userResponse);</span><br><span class="line"></span><br><span class="line">    // request需要重新认证</span><br><span class="line">    case HTTP_UNAUTHORIZED:</span><br><span class="line">      return client.authenticator().authenticate(route, userResponse);</span><br><span class="line"></span><br><span class="line">    // 不需要客户端处理的重定向请求</span><br><span class="line">    case HTTP_PERM_REDIRECT:</span><br><span class="line">    case HTTP_TEMP_REDIRECT:</span><br><span class="line">      // &quot;If the 307 or 308 status code is received in response to a request other than GET</span><br><span class="line">      // or HEAD, the user agent MUST NOT automatically redirect the request&quot;</span><br><span class="line">      if (!method.equals(&quot;GET&quot;) &amp;&amp; !method.equals(&quot;HEAD&quot;)) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line">      // fall-through</span><br><span class="line"></span><br><span class="line">    // 进行重定向</span><br><span class="line">    case HTTP_MULT_CHOICE:</span><br><span class="line">    case HTTP_MOVED_PERM:</span><br><span class="line">    case HTTP_MOVED_TEMP:</span><br><span class="line">    case HTTP_SEE_OTHER:</span><br><span class="line">      // Does the client allow redirects?</span><br><span class="line">      if (!client.followRedirects()) return null;</span><br><span class="line"></span><br><span class="line">      // 获取重定向指定的url</span><br><span class="line">      String location = userResponse.header(&quot;Location&quot;);</span><br><span class="line">      if (location == null) return null;</span><br><span class="line">      // 解析为对应的HttpUrl</span><br><span class="line">      HttpUrl url = userResponse.request().url().resolve(location);</span><br><span class="line"></span><br><span class="line">      // Don&apos;t follow redirects to unsupported protocols.</span><br><span class="line">      if (url == null) return null;</span><br><span class="line"></span><br><span class="line">      // 判断是否重定向的url与原来的url是否是相同的scheme(即http请求还是https请求)</span><br><span class="line">      // 如果不相同，我们又配置了不允许带SSL验证的重定向，则不进行重定向</span><br><span class="line">      // If configured, don&apos;t follow redirects between SSL and non-SSL.</span><br><span class="line">      boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());</span><br><span class="line">      if (!sameScheme &amp;&amp; !client.followSslRedirects()) return null;</span><br><span class="line"></span><br><span class="line">      // 注意，这里是从原来的request复制出一份，所以配置是一样的</span><br><span class="line">      // Most redirects don&apos;t include a request body.</span><br><span class="line">      Request.Builder requestBuilder = userResponse.request().newBuilder();</span><br><span class="line"></span><br><span class="line">      // 是否是允许带有请求体的请求方式(Post允许带有请求体，而Get不允许)</span><br><span class="line">      if (HttpMethod.permitsRequestBody(method)) &#123;</span><br><span class="line">        // 是否允许在重定向过程中，保留之前请求的请求体</span><br><span class="line">        final boolean maintainBody = HttpMethod.redirectsWithBody(method);</span><br><span class="line"></span><br><span class="line">        // 通过Get方式进行重定向，肯定不需要保留请求体</span><br><span class="line">        if (HttpMethod.redirectsToGet(method)) &#123;</span><br><span class="line">          requestBuilder.method(&quot;GET&quot;, null);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          // 设置请求体</span><br><span class="line">          RequestBody requestBody = maintainBody ? userResponse.request().body() : null;</span><br><span class="line">          requestBuilder.method(method, requestBody);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 没有请求体，则移除头部对应的请求体信息</span><br><span class="line">        if (!maintainBody) &#123;</span><br><span class="line">          requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">          requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">          requestBuilder.removeHeader(&quot;Content-Type&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 移除掉原来请求header中的安全认证信息</span><br><span class="line">      // When redirecting across hosts, drop all authentication headers. This</span><br><span class="line">      // is potentially annoying to the application layer since they have no</span><br><span class="line">      // way to retain them.</span><br><span class="line">      if (!sameConnection(userResponse, url)) &#123;</span><br><span class="line">        requestBuilder.removeHeader(&quot;Authorization&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return requestBuilder.url(url).build();</span><br><span class="line"></span><br><span class="line">    // 客户端认证超时，则进行重新请求</span><br><span class="line">    case HTTP_CLIENT_TIMEOUT:</span><br><span class="line">      // 408&apos;s are rare in practice, but some servers like HAProxy use this response code. The</span><br><span class="line">      // spec says that we may repeat the request without modifications. Modern browsers also</span><br><span class="line">      // repeat the request (even non-idempotent ones.)</span><br><span class="line">      if (userResponse.request().body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">        return null;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      return userResponse.request();</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7、intercept</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">  Request request = chain.request();</span><br><span class="line"></span><br><span class="line">  // 此处创建了StreamAllocation，这个StreamAllocation在后续的拦截链流程都需要</span><br><span class="line">  // 用到</span><br><span class="line">  streamAllocation = new StreamAllocation(</span><br><span class="line">      client.connectionPool(), createAddress(request.url()), callStackTrace);</span><br><span class="line"></span><br><span class="line">  // 记录总的重定向的次数</span><br><span class="line">  int followUpCount = 0;</span><br><span class="line">  // 记录上一次请求返回的response</span><br><span class="line">  Response priorResponse = null;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (canceled) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      throw new IOException(&quot;Canceled&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = null;</span><br><span class="line">    boolean releaseConnection = true;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 推动一下个拦截器的执行，在此将StreamAllocation传递给了下一个拦截器，后续拦截器</span><br><span class="line">      // 都可以拿到该实例</span><br><span class="line">      response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);</span><br><span class="line"></span><br><span class="line">      releaseConnection = false;</span><br><span class="line">    &#125; catch (RouteException e) &#123;</span><br><span class="line">      // Route匹配异常，此时request请求是还没有被发送出去的</span><br><span class="line">      // The attempt to connect via a route failed. The request will not have been sent.</span><br><span class="line">      // 检查在该异常下是否允许再进行重试操作</span><br><span class="line">      if (!recover(e.getLastConnectException(), false, request)) &#123;</span><br><span class="line">        throw e.getLastConnectException();</span><br><span class="line">      &#125;</span><br><span class="line">      releaseConnection = false;</span><br><span class="line">      continue;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      // IOException异常下，可能已经向服务端发送了request请求</span><br><span class="line">      // An attempt to communicate with a server failed. The request may have been sent.</span><br><span class="line">      boolean requestSendStarted = !(e instanceof ConnectionShutdownException);</span><br><span class="line">      // 检查在该异常下是否允许再进行重试操作</span><br><span class="line">      if (!recover(e, requestSendStarted, request)) throw e;</span><br><span class="line">      releaseConnection = false;</span><br><span class="line">      continue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // We&apos;re throwing an unchecked exception. Release any resources.</span><br><span class="line">      if (releaseConnection) &#123;</span><br><span class="line">        streamAllocation.streamFailed(null);</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 注意，到这里，Call请求的整个拦截链已经走了一遍，又回到本拦截器中</span><br><span class="line"></span><br><span class="line">    // 如果存在再次请求操作，则重新请求后，返回的response将会保存之前请求的response，这样</span><br><span class="line">    // 多次请求之后，就形成了一个response链，通过当前的response可以查询获取到</span><br><span class="line">    // 之前请求的response</span><br><span class="line">    // Attach the prior response if it exists. Such responses never have a body.</span><br><span class="line">    if (priorResponse != null) &#123;</span><br><span class="line">      response = response.newBuilder()</span><br><span class="line">          .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                  .body(null)</span><br><span class="line">                  .build())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 是否要进行再次请求(不一定是重定向响应导致的，其他情况也可能造成再次请求)</span><br><span class="line">    Request followUp = followUpRequest(response);</span><br><span class="line"></span><br><span class="line">    // 无需进行再次请求，则直接返回response</span><br><span class="line">    if (followUp == null) &#123;</span><br><span class="line">      // 不是WebSocket协议，则直接释放连接</span><br><span class="line">      if (!forWebSocket) &#123;</span><br><span class="line">        streamAllocation.release();</span><br><span class="line">      &#125;</span><br><span class="line">      return response;</span><br><span class="line">    &#125;</span><br><span class="line">    // 需要进行再次请求，则关闭掉当前response响应体的连接(IO连接等)；</span><br><span class="line">    closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">    // 检查总的请求的次数是否超过了最大限制</span><br><span class="line">    if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果再次请求携带的之前的request的请求体是不能重复使用的</span><br><span class="line">    if (followUp.body() instanceof UnrepeatableRequestBody) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      throw new HttpRetryException(&quot;Cannot retry streamed HTTP body&quot;, response.code());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 再次请求的url与之前请求的url是同一个，则释放调用当前的连接</span><br><span class="line">    // 重新创建一个</span><br><span class="line">    if (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">      streamAllocation.release();</span><br><span class="line">      streamAllocation = new StreamAllocation(</span><br><span class="line">          client.connectionPool(), createAddress(followUp.url()), callStackTrace);</span><br><span class="line">    &#125; else if (streamAllocation.codec() != null) &#123;</span><br><span class="line">      throw new IllegalStateException(&quot;Closing the body of &quot; + response</span><br><span class="line">          + &quot; didn&apos;t close its backing stream. Bad interceptor?&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 保存最新的request请求和response</span><br><span class="line">    request = followUp;</span><br><span class="line">    priorResponse = response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RetryAndFollowUpInterceptor虽然是整个系统拦截链的第一个拦截器，但是其作用时期却是在整个Http<br>请求的最后环节；</p>
<p>RetryAndFollowUpInterceptor的一个作用就是捕获整个拦截器链处理过程的异常，判断该异常下是否<br>要重走整个请求流程(注意，不是请求重试和重定向，因为此时followUpCount是重新置为0的，相当于之前<br>的请求都抛弃了，重新再来)。</p>
<p>RetryAndFollowUpInterceptor的另一个作用是在服务端返回response，经过了多个拦截器处理之后，<br>在最终到达RetryAndFollowUpInterceptor这里时，解析response中的响应码，如果需要进行重新请求<br>(可能是要进行重定向，也可能是其他情况，比如客户端超时，导致要进行重新请求)，则会重新创建一个<br>request请求，进行请求，直到请求结束，则将response返回给客户端进行处理；</p>
<p><a href="https://blog.csdn.net/sdfdzx/article/details/78186164" target="_blank" rel="noopener">https://blog.csdn.net/sdfdzx/article/details/78186164</a><br><a href="https://www.jianshu.com/p/e3b6f821acb8" target="_blank" rel="noopener">https://www.jianshu.com/p/e3b6f821acb8</a></p>
<p><a href="https://yq.aliyun.com/articles/78104?spm=a2c4e.11153940.blogcont78101.13.30493cbfGzKQVY" target="_blank" rel="noopener">https://yq.aliyun.com/articles/78104?spm=a2c4e.11153940.blogcont78101.13.30493cbfGzKQVY</a><br><a href="https://www.jianshu.com/p/9deec36f2759" target="_blank" rel="noopener">https://www.jianshu.com/p/9deec36f2759</a><br><a href="https://www.jianshu.com/p/6166d28983a2" target="_blank" rel="noopener">https://www.jianshu.com/p/6166d28983a2</a><br><a href="https://www.jianshu.com/p/671a123ec163" target="_blank" rel="noopener">https://www.jianshu.com/p/671a123ec163</a><br><a href="https://www.jianshu.com/p/92ce01caa8f0" target="_blank" rel="noopener">https://www.jianshu.com/p/92ce01caa8f0</a></p>
<h4 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h4><p>顾名思义，BridgeInterceptor起到桥接的作用。BridgeInterceptor将应用程序的用户请求数据转化为<br>对应网络请求数据；在网络请求之后，又将对应的服务端返回数据，转化为对应的用户相应数据；</p>
<p>BridgeInterceptor为request设置各种请求报头，从response中读取并保存cookie，并解压服务端返回<br>的gzip格式的数据作为response的相应体数据；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line">public final class BridgeInterceptor implements Interceptor &#123;</span><br><span class="line">  // Ok提供的Cookie管理类默认实现是NO_COOKIES，不接受任何cookie</span><br><span class="line">  // 如果要实现cookie保存，则可以实现CookieJar，做自己的实现</span><br><span class="line">  private final CookieJar cookieJar;</span><br><span class="line"></span><br><span class="line">  public BridgeInterceptor(CookieJar cookieJar) &#123;</span><br><span class="line">    this.cookieJar = cookieJar;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    // 获取当前请求request，构造出一个副本</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line"></span><br><span class="line">    // 下面开始构造请求头</span><br><span class="line"></span><br><span class="line">    // request带有请求体</span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    if (body != null) &#123;</span><br><span class="line">      MediaType contentType = body.contentType();</span><br><span class="line">      // 构造Content-Type</span><br><span class="line">      if (contentType != null) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Type&quot;, contentType.toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      // 构造Content-Length</span><br><span class="line">      long contentLength = body.contentLength();</span><br><span class="line">      if (contentLength != -1) &#123;</span><br><span class="line">        requestBuilder.header(&quot;Content-Length&quot;, Long.toString(contentLength));</span><br><span class="line">        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        requestBuilder.header(&quot;Transfer-Encoding&quot;, &quot;chunked&quot;);</span><br><span class="line">        requestBuilder.removeHeader(&quot;Content-Length&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 补充Host</span><br><span class="line">    if (userRequest.header(&quot;Host&quot;) == null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Host&quot;, hostHeader(userRequest.url(), false));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 补充Connection为Keep-Alive，即保持连接，是多路复用的重要步骤</span><br><span class="line">    if (userRequest.header(&quot;Connection&quot;) == null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;Connection&quot;, &quot;Keep-Alive&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 声明客户端支持的压缩编码格式</span><br><span class="line">    // If we add an &quot;Accept-Encoding: gzip&quot; header field we&apos;re responsible for also decompressing</span><br><span class="line">    // the transfer stream.</span><br><span class="line">    boolean transparentGzip = false;</span><br><span class="line">    if (userRequest.header(&quot;Accept-Encoding&quot;) == null &amp;&amp; userRequest.header(&quot;Range&quot;) == null) &#123;</span><br><span class="line">      transparentGzip = true;</span><br><span class="line">      requestBuilder.header(&quot;Accept-Encoding&quot;, &quot;gzip&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据url读取出本地保存的cookie信息，添加到请求头中</span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    if (!cookies.isEmpty()) &#123;</span><br><span class="line">      // 构造请求头</span><br><span class="line">      requestBuilder.header(&quot;Cookie&quot;, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 设置对应浏览器的User-Agent，ok有自己的User-Agent，比如&quot;okhttp/3.7.0&quot;</span><br><span class="line">    if (userRequest.header(&quot;User-Agent&quot;) == null) &#123;</span><br><span class="line">      requestBuilder.header(&quot;User-Agent&quot;, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // request请求头已经设置完毕，构造出一个新的request，传递给下一个拦截器</span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line"></span><br><span class="line">    // 到此，已经完成了一次对服务端的访问，下面开始读取响应头信息</span><br><span class="line"></span><br><span class="line">    // 解析请求头，如果服务端需要往客户端写cookie，则会在响应头中增加&quot;Set-Cookie&quot;，用来向客</span><br><span class="line">    // 户端传递cookie信息；</span><br><span class="line">    // 默认情况下，ok的cookie管理器是NO_COOKIES，即不接收任何cookie信息</span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line"></span><br><span class="line">    // 构造出一个信息的response副本</span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">        .request(userRequest);</span><br><span class="line"></span><br><span class="line">    // 如果响应体中包含了gzip格式的压缩数据，则进行解压，重新赋给副本response的响应体</span><br><span class="line">    if (transparentGzip</span><br><span class="line">        &amp;&amp; &quot;gzip&quot;.equalsIgnoreCase(networkResponse.header(&quot;Content-Encoding&quot;))</span><br><span class="line">        &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">      GzipSource responseBody = new GzipSource(networkResponse.body().source());</span><br><span class="line">      Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">          .removeAll(&quot;Content-Encoding&quot;)</span><br><span class="line">          .removeAll(&quot;Content-Length&quot;)</span><br><span class="line">          .build();</span><br><span class="line">      responseBuilder.headers(strippedHeaders);</span><br><span class="line">      // 这里用到一个新的开源库——Okio 来处理io数据流</span><br><span class="line">      responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return responseBuilder.build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 根据本地读取到的cookie信息，构造一个cookie请求头</span><br><span class="line">  /** Returns a &apos;Cookie&apos; HTTP request header with all cookies, like &#123;@code a=b; c=d&#125;. */</span><br><span class="line">  private String cookieHeader(List&lt;Cookie&gt; cookies) &#123;</span><br><span class="line">    StringBuilder cookieHeader = new StringBuilder();</span><br><span class="line">    for (int i = 0, size = cookies.size(); i &lt; size; i++) &#123;</span><br><span class="line">      if (i &gt; 0) &#123;</span><br><span class="line">        cookieHeader.append(&quot;; &quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      Cookie cookie = cookies.get(i);</span><br><span class="line">      cookieHeader.append(cookie.name()).append(&apos;=&apos;).append(cookie.value());</span><br><span class="line">    &#125;</span><br><span class="line">    return cookieHeader.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BridgeInterceptor的一个职责是构造出一个新的request副本，并解析旧request中的信息，作为请求头<br>添加进新的request中(这就是将应用程序的用户请求数据转化为对应网络请求数据的过程)；</p>
<p>BridgeInterceptor对cookie进行了管理，但ok默认是不接收服务端设置的cookie的，需要我们自己实现<br>cookieJar，完成存取逻辑；</p>
<p>BridgeInterceptor会对服务端返回的gzip格式的响应体进行解压，并重新赋给响应体，这样免去了应用层<br>解压的麻烦；</p>
<p>BridgeInterceptor的另一个职责是构造出一个新的response副本，解析旧response的cookie信息进行<br>保存，解压响应体，赋给新response的响应体(这就是将服务端响应数据转化为用户数据的过程)；</p>
<p><a href="https://www.jianshu.com/p/e3b6f821acb8" target="_blank" rel="noopener">https://www.jianshu.com/p/e3b6f821acb8</a><br><a href="https://yq.aliyun.com/articles/78104?spm=a2c4e.11153940.blogcont78105.12.563837beQ4QiO4" target="_blank" rel="noopener">https://yq.aliyun.com/articles/78104?spm=a2c4e.11153940.blogcont78105.12.563837beQ4QiO4</a></p>
<h4 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h4><p>CacheInterceptor用来决策当前网络请求是否使用缓存，并且会根据缓存策略决定是否进行缓存和删除缓<br>存。</p>
<h5 id="CacheStrategy"><a href="#CacheStrategy" class="headerlink" title="CacheStrategy"></a>CacheStrategy</h5><p>CacheStrategy接收当前request请求和可能存在的response缓存，并根据这两者设置的头数据来决策是<br>使用缓存，还是进行网络请求，还是两者都进行；</p>
<p>1、CacheStrategy</p>
<p>根据response的状态码判断当前的response是否能被缓存；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isCacheable(Response response, Request request) &#123;</span><br><span class="line">  // Always go to network for uncacheable response codes (RFC 7231 section 6.1),</span><br><span class="line">  // This implementation doesn&apos;t support caching partial content.</span><br><span class="line">  switch (response.code()) &#123;</span><br><span class="line">    // 这种状态码的response允许被缓存</span><br><span class="line">    case HTTP_OK:</span><br><span class="line">    case HTTP_NOT_AUTHORITATIVE:</span><br><span class="line">    case HTTP_NO_CONTENT:</span><br><span class="line">    case HTTP_MULT_CHOICE:</span><br><span class="line">    case HTTP_MOVED_PERM:</span><br><span class="line">    case HTTP_NOT_FOUND:</span><br><span class="line">    case HTTP_BAD_METHOD:</span><br><span class="line">    case HTTP_GONE:</span><br><span class="line">    case HTTP_REQ_TOO_LONG:</span><br><span class="line">    case HTTP_NOT_IMPLEMENTED:</span><br><span class="line">    case StatusLine.HTTP_PERM_REDIRECT:</span><br><span class="line">      // These codes can be cached unless headers forbid it.</span><br><span class="line">      break;</span><br><span class="line"></span><br><span class="line">    // 这两种状态码下如果响应头是合适的，则会进行缓存</span><br><span class="line">    case HTTP_MOVED_TEMP:</span><br><span class="line">    case StatusLine.HTTP_TEMP_REDIRECT:</span><br><span class="line">      // These codes can only be cached with the right response headers.</span><br><span class="line">      // http://tools.ietf.org/html/rfc7234#section-3</span><br><span class="line"></span><br><span class="line">      // s-maxage这种Cache-Control(会覆盖max-age和Expires效果)标识被直接忽略，因为这种标识</span><br><span class="line">      // 只能作用于共享缓存，而ok进行的是私有缓存(个人觉得这个应该理解为接收私有和共享两种缓存</span><br><span class="line">      // 对于s-maxage这种只能作用于共享缓存的情况，ok选择不缓存该response，否则缓存是私有的，</span><br><span class="line">      // 将不知道何时过期);</span><br><span class="line">      // s-maxage is not checked because OkHttp is a private cache that should ignore s-maxage.</span><br><span class="line">      if (response.header(&quot;Expires&quot;) != null</span><br><span class="line">          || response.cacheControl().maxAgeSeconds() != -1</span><br><span class="line">          || response.cacheControl().isPublic()</span><br><span class="line">          || response.cacheControl().isPrivate()) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      // Fall-through.</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">      // All other codes cannot be cached.</span><br><span class="line">      return false;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Cache-Control标志是no-store，表示不缓存任何客户端请求和服务端响应</span><br><span class="line">  // A &apos;no-store&apos; directive on request or response prevents the response from being cached.</span><br><span class="line">  return !response.cacheControl().noStore() &amp;&amp; !request.cacheControl().noStore();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、Factory</p>
<p>根据request、response和系统当前事件构造相应的CacheStrategy实例；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public static class Factory &#123;</span><br><span class="line">  final long nowMillis;</span><br><span class="line">  final Request request;</span><br><span class="line">  final Response cacheResponse;</span><br><span class="line"></span><br><span class="line">  // 对应响应头中的Date标识，记录服务端产生响应数据的时间</span><br><span class="line">  /** The server&apos;s time when the cached response was served, if known. */</span><br><span class="line">  private Date servedDate;</span><br><span class="line">  private String servedDateString;</span><br><span class="line"></span><br><span class="line">  // 对应响应头中的Last-Modified标识，记录缓存在服务端最后一次的修改时间，用于对比缓存</span><br><span class="line">  /** The last modified date of the cached response, if known. */</span><br><span class="line">  private Date lastModified;</span><br><span class="line">  private String lastModifiedString;</span><br><span class="line"></span><br><span class="line">  // 对应响应头的expires标识，记录服务端设置的缓存过期时间，因为服务端和客户端可能存在时间差异</span><br><span class="line">  // 所以存在误差，推荐max-age来记录过期时间(expires在HTTP/1.1已经被抛弃)</span><br><span class="line">  /**</span><br><span class="line">   * The expiration date of the cached response, if known. If both this field and the max age are</span><br><span class="line">   * set, the max age is preferred.</span><br><span class="line">   */</span><br><span class="line">  private Date expires;</span><br><span class="line"></span><br><span class="line">  // 记录Ok第一次发出该request时的时间，在有缓存的情况下，则不是当前系统时间，而是之前发送获取缓存的</span><br><span class="line">  // request的发送时间</span><br><span class="line">  /**</span><br><span class="line">   * Extension header set by OkHttp specifying the timestamp when the cached HTTP request was</span><br><span class="line">   * first initiated.</span><br><span class="line">   */</span><br><span class="line">  private long sentRequestMillis;</span><br><span class="line"></span><br><span class="line">  // 记录Ok第一次接收到该response的时间，可能是缓存response的时间</span><br><span class="line">  /**</span><br><span class="line">   * Extension header set by OkHttp specifying the timestamp when the cached HTTP response was</span><br><span class="line">   * first received.</span><br><span class="line">   */</span><br><span class="line">  private long receivedResponseMillis;</span><br><span class="line"></span><br><span class="line">  // 对应响应头的ETag标识，用于唯一识别缓存，用于对比缓存</span><br><span class="line">  /** Etag of the cached response. */</span><br><span class="line">  private String etag;</span><br><span class="line"></span><br><span class="line">  // 对应响应头的Age标识，记录响应消息在代理服务器中存储的时长</span><br><span class="line">  /** Age of the cached response. */</span><br><span class="line">  private int ageSeconds = -1;</span><br></pre></td></tr></table></figure>
<p>3、构造方法</p>
<p>接收当前系统时间、request请求和缓存的response，解析缓存和有效期有关的响应头数据；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public Factory(long nowMillis, Request request, Response cacheResponse) &#123;</span><br><span class="line">  this.nowMillis = nowMillis;</span><br><span class="line">  this.request = request;</span><br><span class="line">  this.cacheResponse = cacheResponse;</span><br><span class="line"></span><br><span class="line">  if (cacheResponse != null) &#123;</span><br><span class="line">    // 拿到缓存response对应的request发出时间</span><br><span class="line">    this.sentRequestMillis = cacheResponse.sentRequestAtMillis();</span><br><span class="line">    // 拿到从服务端接收缓存response时的时间</span><br><span class="line">    this.receivedResponseMillis = cacheResponse.receivedResponseAtMillis();</span><br><span class="line"></span><br><span class="line">    // 解析缓存的响应头</span><br><span class="line">    Headers headers = cacheResponse.headers();</span><br><span class="line">    for (int i = 0, size = headers.size(); i &lt; size; i++) &#123;</span><br><span class="line">      String fieldName = headers.name(i);</span><br><span class="line">      String value = headers.value(i);</span><br><span class="line"></span><br><span class="line">      // 服务端生成响应时的时间</span><br><span class="line">      if (&quot;Date&quot;.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">        servedDate = HttpDate.parse(value);</span><br><span class="line">        servedDateString = value;</span><br><span class="line"></span><br><span class="line">      // 缓存过期时间</span><br><span class="line">      &#125; else if (&quot;Expires&quot;.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">        expires = HttpDate.parse(value);</span><br><span class="line"></span><br><span class="line">      // 服务端返回的记录缓存数据在服务端上次修改的时间</span><br><span class="line">      &#125; else if (&quot;Last-Modified&quot;.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">        lastModified = HttpDate.parse(value);</span><br><span class="line">        lastModifiedString = value;</span><br><span class="line"></span><br><span class="line">      // 缓存的唯一标识</span><br><span class="line">      &#125; else if (&quot;ETag&quot;.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">        etag = value;</span><br><span class="line"></span><br><span class="line">      // 缓存在代理服务器保存的时间</span><br><span class="line">      &#125; else if (&quot;Age&quot;.equalsIgnoreCase(fieldName)) &#123;</span><br><span class="line">        ageSeconds = HttpHeaders.parseSeconds(value, -1);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、getCandidate</p>
<p>解析缓存响应头中的关于缓存使用期限的标识，构造出新的request、response或者为空的response；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">private CacheStrategy getCandidate() &#123;</span><br><span class="line">  // No cached response.</span><br><span class="line">  if (cacheResponse == null) &#123;</span><br><span class="line">    return new CacheStrategy(request, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Drop the cached response if it&apos;s missing a required handshake.</span><br><span class="line">  if (request.isHttps() &amp;&amp; cacheResponse.handshake() == null) &#123;</span><br><span class="line">    return new CacheStrategy(request, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 检查缓存response中的状态码，如果对应状态码下是不允许缓存的，则返回空的response</span><br><span class="line">  // 这种情况正常情况下是不会出现，因为在第一次从服务端请求到数据后，在缓存之前就会进行</span><br><span class="line">  // 一次检查，所以这里的操作是多余的</span><br><span class="line">  // If this response shouldn&apos;t have been stored, it should never be used</span><br><span class="line">  // as a response source. This check should be redundant as long as the</span><br><span class="line">  // persistence store is well-behaved and the rules are constant.</span><br><span class="line">  if (!isCacheable(cacheResponse, request)) &#123;</span><br><span class="line">    return new CacheStrategy(request, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // request设置了不需要走缓存或者这个request实际是对比缓存中发给服务端的验证请求</span><br><span class="line">  CacheControl requestCaching = request.cacheControl();</span><br><span class="line">  if (requestCaching.noCache() || hasConditions(request)) &#123;</span><br><span class="line">    return new CacheStrategy(request, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 这个response存活的时间(当前系统时间 - 首次request请求时的时间)</span><br><span class="line">  long ageMillis = cacheResponseAge();</span><br><span class="line">  // 这个response的有效时长，如果设置了多种，首推max-age</span><br><span class="line">  long freshMillis = computeFreshnessLifetime();</span><br><span class="line"></span><br><span class="line">  // 获取request请求中设置的max-age值</span><br><span class="line">  if (requestCaching.maxAgeSeconds() != -1) &#123;</span><br><span class="line">    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 获取request请求中设置的min-fresh值</span><br><span class="line">  long minFreshMillis = 0;</span><br><span class="line">  if (requestCaching.minFreshSeconds() != -1) &#123;</span><br><span class="line">    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 缓存response中没有强制缓存过期就不能用，并且request中设置了允许最大的过期时间</span><br><span class="line">  long maxStaleMillis = 0;</span><br><span class="line">  CacheControl responseCaching = cacheResponse.cacheControl();</span><br><span class="line">  if (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -1) &#123;</span><br><span class="line">    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 缓存不是对比缓存，(ageMillis + minFreshMillis)为缓存实际存活时间，包含了已存活时间ageMillis</span><br><span class="line">  // 和还能存活时间minFreshMillis，在缓存有效期内，(ageMillis + minFreshMillis)的值是固定的，</span><br><span class="line">  // 超过有效期，此时minFreshMillis为0，ageMillis大于原来(ageMillis + minFreshMillis)，注意</span><br><span class="line">  // 这里的有效期是绝对的有效期，超过绝对有效期不一定失效，还有看是否大于(freshMillis + maxStaleMillis)</span><br><span class="line">  if (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</span><br><span class="line">    Response.Builder builder = cacheResponse.newBuilder();</span><br><span class="line">    // 缓存过期了，但没有超过最大的过期期限，还是能用的</span><br><span class="line">    if (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</span><br><span class="line">      builder.addHeader(&quot;Warning&quot;, &quot;110 HttpURLConnection \&quot;Response is stale\&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 当缓存设置的有效期非常长时，超过了一天，虽然能够使用缓存，但必须进行警告</span><br><span class="line">    long oneDayMillis = 24 * 60 * 60 * 1000L;</span><br><span class="line">    if (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</span><br><span class="line">      builder.addHeader(&quot;Warning&quot;, &quot;113 HttpURLConnection \&quot;Heuristic expiration\&quot;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return new CacheStrategy(null, builder.build());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 下面是对比缓存的情况</span><br><span class="line"></span><br><span class="line">  // 如果缓存是对比缓存，则在使用缓存之前，必须先发一个request带上缓存响应头对应的标识值于服务端</span><br><span class="line">  // 进行验证，验证缓存有效，才能使用，否则必须重新请求</span><br><span class="line">  // Find a condition to add to the request. If the condition is satisfied, the response body</span><br><span class="line">  // will not be transmitted.</span><br><span class="line">  String conditionName;</span><br><span class="line">  String conditionValue;</span><br><span class="line">  if (etag != null) &#123;</span><br><span class="line">    conditionName = &quot;If-None-Match&quot;;</span><br><span class="line">    conditionValue = etag;</span><br><span class="line">  &#125; else if (lastModified != null) &#123;</span><br><span class="line">    conditionName = &quot;If-Modified-Since&quot;;</span><br><span class="line">    conditionValue = lastModifiedString;</span><br><span class="line">  &#125; else if (servedDate != null) &#123;</span><br><span class="line">    conditionName = &quot;If-Modified-Since&quot;;</span><br><span class="line">    conditionValue = servedDateString;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return new CacheStrategy(request, null); // No condition! Make a regular request.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 构造出对比缓存的验证request</span><br><span class="line">  Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</span><br><span class="line">  Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</span><br><span class="line"></span><br><span class="line">  Request conditionalRequest = request.newBuilder()</span><br><span class="line">      .headers(conditionalRequestHeaders.build())</span><br><span class="line">      .build();</span><br><span class="line">  return new CacheStrategy(conditionalRequest, cacheResponse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5、get</p>
<p>调用getCandidate方法，获取CacheStrategy实例，但并不一定使用，还要进行多一层判断；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public CacheStrategy get() &#123;</span><br><span class="line">  CacheStrategy candidate = getCandidate();</span><br><span class="line"></span><br><span class="line">  // 如果networkRequest不为空，表明必须进行一次请求网络才能获取数据了(可能是验证，不一定是请求)</span><br><span class="line">  // 如果检查到request设置了强制走缓存，不能进行网络请求，则返回空的response内容和504响应码</span><br><span class="line">  if (candidate.networkRequest != null &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</span><br><span class="line">    // We&apos;re forbidden from using the network and the cache is insufficient.</span><br><span class="line">    return new CacheStrategy(null, null);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return candidate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="CacheInterceptor-1"><a href="#CacheInterceptor-1" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h5><p>成员变量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final InternalCache cache;</span><br></pre></td></tr></table></figure>
<p>CacheInterceptor 只有一个成员变量cache，提供了缓存、读取、删除、更新response的功能，并且以<br>请求的url为key；</p>
<p><em>ok提供了默认的cache(基于DiskLruCache)，使用时我们只需要创建对应Cache实例即可。当然，我们<br>还可以实习自己的缓存类，只需要实现InternalCache接口即可。</em></p>
<p>intercept</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">  Response cacheCandidate = cache != null</span><br><span class="line">      ? cache.get(chain.request())</span><br><span class="line">      : null;</span><br><span class="line"></span><br><span class="line">  long now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">  // 根据request请求和缓存的response的头数据决策出新的request和response</span><br><span class="line">  // 如果networkRequest不为空，则表示需要进行网络请求，如果cacheResponse不会null，则是于服</span><br><span class="line">  // 务端进行验证，检查本地缓存的有效性,否则cacheResponse为null，则是需要向服务端请求数据；</span><br><span class="line"></span><br><span class="line">  // 如果networkRequest为null，则表明不进行网络请求，此时如果cacheResponse不为null，则说明</span><br><span class="line">  // 有缓存可以使用；否则cacheResponse为null，表明cache存在问题，无法满足请求，报504错误</span><br><span class="line">  CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">  Request networkRequest = strategy.networkRequest;</span><br><span class="line">  Response cacheResponse = strategy.cacheResponse;</span><br><span class="line"></span><br><span class="line">  // 记录通过缓存取数据的次数</span><br><span class="line">  if (cache != null) &#123;</span><br><span class="line">    cache.trackResponse(strategy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 缓存response不可用，关闭</span><br><span class="line">  if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">    closeQuietly(cacheCandidate.body()); // The cache candidate wasn&apos;t applicable. Close it.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 不允许进行网络请求(only-if-cached)，又没有缓存数据，则构造504错误</span><br><span class="line">  // If we&apos;re forbidden from using the network and the cache is insufficient, fail.</span><br><span class="line">  if (networkRequest == null &amp;&amp; cacheResponse == null) &#123;</span><br><span class="line">    return new Response.Builder()</span><br><span class="line">        .request(chain.request())</span><br><span class="line">        .protocol(Protocol.HTTP_1_1)</span><br><span class="line">        .code(504)</span><br><span class="line">        .message(&quot;Unsatisfiable Request (only-if-cached)&quot;)</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .sentRequestAtMillis(-1L)</span><br><span class="line">        .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 走缓存</span><br><span class="line">  // If we don&apos;t need the network, we&apos;re done.</span><br><span class="line">  if (networkRequest == null) &#123;</span><br><span class="line">    return cacheResponse.newBuilder()</span><br><span class="line">        .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 走网络请求</span><br><span class="line">  Response networkResponse = null;</span><br><span class="line">  try &#123;</span><br><span class="line">    networkResponse = chain.proceed(networkRequest);</span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    // If we&apos;re crashing on I/O or otherwise, don&apos;t leak the cache body.</span><br><span class="line">    if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123;</span><br><span class="line">      closeQuietly(cacheCandidate.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 对比缓存，于服务端进行对比验证后，发现缓存没有过期，可以继续使用</span><br><span class="line">  // If we have a cache response too, then we&apos;re doing a conditional get.</span><br><span class="line">  if (cacheResponse != null) &#123;</span><br><span class="line">    if (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">      // 合并缓存response和此次response</span><br><span class="line">      // 更新sentRequestAtMillis和receivedResponseAtMillis应该是说明缓存刷新了</span><br><span class="line">      Response response = cacheResponse.newBuilder()</span><br><span class="line">          .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">          .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">          .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">          .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">          .networkResponse(stripBody(networkResponse))</span><br><span class="line">          .build();</span><br><span class="line">      networkResponse.body().close();</span><br><span class="line"></span><br><span class="line">      // Update the cache after combining headers but before stripping the</span><br><span class="line">      // Content-Encoding header (as performed by initContentStream()).</span><br><span class="line">      cache.trackConditionalCacheHit();</span><br><span class="line">      // 更新本地缓存</span><br><span class="line">      cache.update(cacheResponse, response);</span><br><span class="line">      return response;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      closeQuietly(cacheResponse.body());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 普通的服务端请求，从服务端请求数据</span><br><span class="line">  // stripBody的作用是剔除掉response中的body数据</span><br><span class="line">  Response response = networkResponse.newBuilder()</span><br><span class="line">      .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">      .networkResponse(stripBody(networkResponse))</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  if (cache != null) &#123;</span><br><span class="line">    // 存在响应体，并且response是可以被缓存的，则对response进行缓存</span><br><span class="line">    if (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">      // Offer this request to the cache.</span><br><span class="line">      CacheRequest cacheRequest = cache.put(response);</span><br><span class="line"></span><br><span class="line">      // 因为缓存response和用户读取response数据存在冲突(不能被同时持有)，所以要构造出一个包</span><br><span class="line">      // 含新的data source的response，专门用来支持缓存读取；</span><br><span class="line">      return cacheWritingResponse(cacheRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 缓存是无效的，进行移除</span><br><span class="line">    if (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        cache.remove(networkRequest);</span><br><span class="line">      &#125; catch (IOException ignored) &#123;</span><br><span class="line">        // The cache cannot be written.</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CacheInterceptor的主要职责是管理response缓存，正常情况下，除非在response和request中显式<br>指定了no-store，否则只要提供了Cache，则ok会为我们缓存存在响应体的response数据；</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Age" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Age</a><br><a href="https://www.jianshu.com/p/b32d13655be7" target="_blank" rel="noopener">https://www.jianshu.com/p/b32d13655be7</a><br><a href="https://yq.aliyun.com/articles/78104?spm=a2c4e.11153940.blogcont78105.12.563837beQ4QiO4" target="_blank" rel="noopener">https://yq.aliyun.com/articles/78104?spm=a2c4e.11153940.blogcont78105.12.563837beQ4QiO4</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Age</a><br><a href="https://blog.csdn.net/cominglately/article/details/77685214" target="_blank" rel="noopener">https://blog.csdn.net/cominglately/article/details/77685214</a></p>
<h4 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h4><blockquote>
<p>ConnectInterceptor职责很简单，就是管理当前Call请求与服务端的连接；</p>
</blockquote>
<h5 id="RealConnection"><a href="#RealConnection" class="headerlink" title="RealConnection"></a>RealConnection</h5><p>RealConnection负责与服务端建立连接(通过三次握手、四次挥手)；</p>
<p>RealConnection创建、包装和操作Socket，每一个RealConnection对应一个连接的Socket；</p>
<p>RealConnection代表连接Socket的链路，如果创建了RealConnection实例，则表明我们已经跟服务端建立<br>了一条通信链路；</p>
<p>RealConnection采用的连接协议有HTTP1.x、HTTPS和HTTP2三种网络协议进行连接；</p>
<p>当RealConnection是基于HTTP2协议是，则可以承载多个数据流(对应多个StreamAllocation)；</p>
<p>建立HTTPS和HTTP2的流程是先创建一个普通的rawSocket，可以用来完成HTTP1.x请求，如果当前连接支持<br>HTTPS或HTTP2，则会在构造SSLSocket，用来完成带安全验证的HTTP请求；</p>
<p>属性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">private final ConnectionPool connectionPool;</span><br><span class="line">private final Route route;</span><br><span class="line"></span><br><span class="line">// The fields below are initialized by connect() and never reassigned.</span><br><span class="line">// 下面的变量在调用connect方法进行连接时被初始化</span><br><span class="line">/** The low-level TCP socket. */</span><br><span class="line">// rawSocket可以认为是普通的Socket，基于HTTP协议</span><br><span class="line">private Socket rawSocket;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The application layer socket. Either an &#123;@link SSLSocket&#125; layered over &#123;@link #rawSocket&#125;, or</span><br><span class="line"> * &#123;@link #rawSocket&#125; itself if this connection does not use SSL.</span><br><span class="line"> */</span><br><span class="line">// 应用层的Socket，如果没有使用SSL协议，则会使用SSLSocket或者直接是rawSocket</span><br><span class="line">// 否则将是基于HTTPS安全协议的SSLSocket，应用与HTTPS和HTTP2协议</span><br><span class="line">private Socket socket;</span><br><span class="line">// 基于HTTPS，描述握手协议的</span><br><span class="line">private Handshake handshake;</span><br><span class="line">// 描述协议类型(HTTP1.0/HTTP1.1/HTTP2等)</span><br><span class="line">private Protocol protocol;</span><br><span class="line">// Http2使用的连接</span><br><span class="line">private Http2Connection http2Connection;</span><br><span class="line"></span><br><span class="line">与服务端数据交互的输入输出流</span><br><span class="line">private BufferedSource source;</span><br><span class="line">private BufferedSink sink;</span><br><span class="line"></span><br><span class="line">// The fields below track connection state and are guarded by connectionPool.</span><br><span class="line">// 下面的变量是用来跟踪连接状态的，并且由连接池进行管理</span><br><span class="line"></span><br><span class="line">/** If true, no new streams can be created on this connection. Once true this is always true. */</span><br><span class="line">// 如果为true，表示当前连接池不能再创建新的stream流</span><br><span class="line">public boolean noNewStreams;</span><br><span class="line"></span><br><span class="line">// 记录连接成功的次数</span><br><span class="line">public int successCount;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The maximum number of concurrent streams that can be carried by this connection. If &#123;@code</span><br><span class="line"> * allocations.size() &lt; allocationLimit&#125; then new streams can be created on this connection.</span><br><span class="line"> */</span><br><span class="line">// 当前连接可以承载的Stream流个数，如果个数小于这里声明的值，则该连接可以创建新的Stream流</span><br><span class="line">// HTTP1.x只能够承载1个，而HTTP2能够承载多个</span><br><span class="line">public int allocationLimit = 1;</span><br><span class="line"></span><br><span class="line">// 当前连接承载的Stream流集合</span><br><span class="line">/** Current streams carried by this connection. */</span><br><span class="line">public final List&lt;Reference&lt;StreamAllocation&gt;&gt; allocations = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">/** Nanotime timestamp when &#123;@code allocations.size()&#125; reached zero. */</span><br><span class="line">public long idleAtNanos = Long.MAX_VALUE;</span><br></pre></td></tr></table></figure>
<h6 id="connectSocket"><a href="#connectSocket" class="headerlink" title="connectSocket"></a>connectSocket</h6><p>创建一个最基本的Socket，支持HTTP连接，并且可以扩展为HTTPS连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/** Does all the work necessary to build a full HTTP or HTTPS connection on a raw socket. */</span><br><span class="line">private void connectSocket(int connectTimeout, int readTimeout) throws IOException &#123;</span><br><span class="line">  Proxy proxy = route.proxy();</span><br><span class="line">  Address address = route.address();</span><br><span class="line"></span><br><span class="line">  // 创建直连或者有代理的Socket</span><br><span class="line">  rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP</span><br><span class="line">      ? address.socketFactory().createSocket()</span><br><span class="line">      : new Socket(proxy);</span><br><span class="line"></span><br><span class="line">  rawSocket.setSoTimeout(readTimeout);</span><br><span class="line">  try &#123;</span><br><span class="line">    // 连接Socket</span><br><span class="line">    Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout);</span><br><span class="line">  &#125; catch (ConnectException e) &#123;</span><br><span class="line">    ConnectException ce = new ConnectException(&quot;Failed to connect to &quot; + route.socketAddress());</span><br><span class="line">    ce.initCause(e);</span><br><span class="line">    throw ce;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 创建Socket的输入/输出流</span><br><span class="line">  source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line">  sink = Okio.buffer(Okio.sink(rawSocket));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="createTunnel"><a href="#createTunnel" class="headerlink" title="createTunnel"></a>createTunnel</h6><p>创建一个连接管道；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">private Request createTunnel(int readTimeout, int writeTimeout, Request tunnelRequest,</span><br><span class="line">    HttpUrl url) throws IOException &#123;</span><br><span class="line">  // Make an SSL Tunnel on the first message pair of each SSL + proxy connection.</span><br><span class="line">  String requestLine = &quot;CONNECT &quot; + Util.hostHeader(url, true) + &quot; HTTP/1.1&quot;;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    // 基于HTTP1.1的Socket数据通讯封装类</span><br><span class="line">    Http1Codec tunnelConnection = new Http1Codec(null, null, source, sink);</span><br><span class="line">    source.timeout().timeout(readTimeout, MILLISECONDS);</span><br><span class="line">    sink.timeout().timeout(writeTimeout, MILLISECONDS);</span><br><span class="line">    // 发送建立管道连接请求</span><br><span class="line">    tunnelConnection.writeRequest(tunnelRequest.headers(), requestLine);</span><br><span class="line">    tunnelConnection.finishRequest();</span><br><span class="line">    Response response = tunnelConnection.readResponseHeaders(false)</span><br><span class="line">        .request(tunnelRequest)</span><br><span class="line">        .build();</span><br><span class="line">    // The response body from a CONNECT should be empty, but if it is not then we should consume</span><br><span class="line">    // it before proceeding.</span><br><span class="line"></span><br><span class="line">    // 检查管道是否建立</span><br><span class="line">    long contentLength = HttpHeaders.contentLength(response);</span><br><span class="line">    if (contentLength == -1L) &#123;</span><br><span class="line">      contentLength = 0L;</span><br><span class="line">    &#125;</span><br><span class="line">    Source body = tunnelConnection.newFixedLengthSource(contentLength);</span><br><span class="line">    Util.skipAll(body, Integer.MAX_VALUE, TimeUnit.MILLISECONDS);</span><br><span class="line">    body.close();</span><br><span class="line"></span><br><span class="line">    switch (response.code()) &#123;</span><br><span class="line">      case HTTP_OK:</span><br><span class="line">        // Assume the server won&apos;t send a TLS ServerHello until we send a TLS ClientHello. If</span><br><span class="line">        // that happens, then we will have buffered bytes that are needed by the SSLSocket!</span><br><span class="line">        // This check is imperfect: it doesn&apos;t tell us whether a handshake will succeed, just</span><br><span class="line">        // that it will almost certainly fail because the proxy has sent unexpected data.</span><br><span class="line">        if (!source.buffer().exhausted() || !sink.buffer().exhausted()) &#123;</span><br><span class="line">          throw new IOException(&quot;TLS tunnel buffered too many bytes!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line"></span><br><span class="line">      case HTTP_PROXY_AUTH:</span><br><span class="line">        tunnelRequest = route.address().proxyAuthenticator().authenticate(route, response);</span><br><span class="line">        if (tunnelRequest == null) throw new IOException(&quot;Failed to authenticate with proxy&quot;);</span><br><span class="line"></span><br><span class="line">        if (&quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) &#123;</span><br><span class="line">          return tunnelRequest;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">      default:</span><br><span class="line">        throw new IOException(</span><br><span class="line">            &quot;Unexpected response code for CONNECT: &quot; + response.code());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="connectTunnel"><a href="#connectTunnel" class="headerlink" title="connectTunnel"></a>connectTunnel</h6><p>以管道方式建立连接(就是建立一个TCP长连接，将所有的请求都交给这个连接处理，这些请求被按顺序发送和<br>接收，当一个请求耗时过长时，后续请求将会受到阻塞)；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">private void connectTunnel(int connectTimeout, int readTimeout, int writeTimeout)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">  // 构造一个管道请求</span><br><span class="line">  Request tunnelRequest = createTunnelRequest();</span><br><span class="line">  HttpUrl url = tunnelRequest.url();</span><br><span class="line">  int attemptedConnections = 0;</span><br><span class="line">  int maxAttempts = 21;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    if (++attemptedConnections &gt; maxAttempts) &#123;</span><br><span class="line">      throw new ProtocolException(&quot;Too many tunnel connections attempted: &quot; + maxAttempts);</span><br><span class="line">    &#125;</span><br><span class="line">    // 创建Socket</span><br><span class="line">    connectSocket(connectTimeout, readTimeout);</span><br><span class="line">    // 创建一个管道连接</span><br><span class="line">    tunnelRequest = createTunnel(readTimeout, writeTimeout, tunnelRequest, url);</span><br><span class="line"></span><br><span class="line">    if (tunnelRequest == null) break; // Tunnel successfully created.</span><br><span class="line"></span><br><span class="line">    // The proxy decided to close the connection after an auth challenge. We need to create a new</span><br><span class="line">    // connection, but this time with the auth credentials.</span><br><span class="line">    closeQuietly(rawSocket);</span><br><span class="line">    rawSocket = null;</span><br><span class="line">    sink = null;</span><br><span class="line">    source = null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="establishProtocol"><a href="#establishProtocol" class="headerlink" title="establishProtocol"></a>establishProtocol</h6><p>如果是基于HTTPS或者HTTP2协议的连接，则必须经过下面的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private void establishProtocol(ConnectionSpecSelector connectionSpecSelector) throws IOException &#123;</span><br><span class="line">  // 无法创建SSLSocket(基于SSL和TLS协议的Socket，提供HTTPS连接支持)</span><br><span class="line">  if (route.address().sslSocketFactory() == null) &#123;</span><br><span class="line">    protocol = Protocol.HTTP_1_1;</span><br><span class="line">    socket = rawSocket;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 创建SSLSocket</span><br><span class="line">  // 如果HTTPS支持TLS协议，则采用TLS协议，否则是SSL协议</span><br><span class="line">  connectTls(connectionSpecSelector);</span><br><span class="line"></span><br><span class="line">  // 采用HTTP2协议进行连接</span><br><span class="line">  // HTTP2协议默认基于TLS和SSL协议安全加密的</span><br><span class="line">  if (protocol == Protocol.HTTP_2) &#123;</span><br><span class="line">    socket.setSoTimeout(0); // HTTP/2 connection timeouts are set per-stream.</span><br><span class="line">    http2Connection = new Http2Connection.Builder(true)</span><br><span class="line">        .socket(socket, route.address().url().host(), source, sink)</span><br><span class="line">        .listener(this)</span><br><span class="line">        .build();</span><br><span class="line">    http2Connection.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public void connect(</span><br><span class="line">    int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) &#123;</span><br><span class="line">  if (protocol != null) throw new IllegalStateException(&quot;already connected&quot;);</span><br><span class="line"></span><br><span class="line">  RouteException routeException = null;</span><br><span class="line">  // ConnectionSpec是描述Socket连接的协议信息</span><br><span class="line">  List&lt;ConnectionSpec&gt; connectionSpecs = route.address().connectionSpecs();</span><br><span class="line">  // ConnectionSpecSelector用来选择合适的ConnectionSpec，当握手或者协议出现问题的时候，需</span><br><span class="line">  // 要尝试不同的协议进行连接</span><br><span class="line">  ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs);</span><br><span class="line"></span><br><span class="line">  // Https安全连接需要的证书验证</span><br><span class="line">  if (route.address().sslSocketFactory() == null) &#123;</span><br><span class="line">    if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123;</span><br><span class="line">      throw new RouteException(new UnknownServiceException(</span><br><span class="line">          &quot;CLEARTEXT communication not enabled for client&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">    String host = route.address().url().host();</span><br><span class="line">    if (!Platform.get().isCleartextTrafficPermitted(host)) &#123;</span><br><span class="line">      throw new RouteException(new UnknownServiceException(</span><br><span class="line">          &quot;CLEARTEXT communication to &quot; + host + &quot; not permitted by network security policy&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while (true) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      // 基于持久化的管道连接，使用较少</span><br><span class="line">      if (route.requiresTunnel()) &#123;</span><br><span class="line">        connectTunnel(connectTimeout, readTimeout, writeTimeout);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // 一般情况都是这种，创建并连接Socket</span><br><span class="line">        // 此时rawSocket被创建</span><br><span class="line">        connectSocket(connectTimeout, readTimeout);</span><br><span class="line">      &#125;</span><br><span class="line">      // 构建安全传输协议，如果支持SSL或者TLS，则在rawSocket基础上进行包装为SSLSocket</span><br><span class="line">      establishProtocol(connectionSpecSelector);</span><br><span class="line">      break;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">      closeQuietly(socket);</span><br><span class="line">      closeQuietly(rawSocket);</span><br><span class="line">      socket = null;</span><br><span class="line">      rawSocket = null;</span><br><span class="line">      source = null;</span><br><span class="line">      sink = null;</span><br><span class="line">      handshake = null;</span><br><span class="line">      protocol = null;</span><br><span class="line">      http2Connection = null;</span><br><span class="line"></span><br><span class="line">      if (routeException == null) &#123;</span><br><span class="line">        routeException = new RouteException(e);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        routeException.addConnectException(e);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123;</span><br><span class="line">        throw routeException;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (http2Connection != null) &#123;</span><br><span class="line">    synchronized (connectionPool) &#123;</span><br><span class="line">      allocationLimit = http2Connection.maxConcurrentStreams();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="StreamAllocation"><a href="#StreamAllocation" class="headerlink" title="StreamAllocation"></a>StreamAllocation</h5><p>StreamAllocation的作用是协调连接(Connections)、数据流(Streams)和请求(Calls)之间的关系；</p>
<p>连接指的是Socket与远程服务端的连接。创建连接的过程可能很缓慢，所以我们可以直接取消掉一个<br>正在创建的连接。</p>
<p>数据流表示建立在连接之上的逻辑请求和响应数据。每一个连接能够携带的数据流个数都是有限制的，HTTP1.x<br>协议，每一个连接都只能够携带一个数据流，而HTTP2采用了连接复用技术，所以同一连接可以携带多个数据流。</p>
<p>请求，即Call请求，通过request发起。一个请求对应了一些列的数据流，典型的是一个初始化请求和其后的<br>一系列重定向请求，每一个请求对应一个数据流。我们更希望一个请求的所有数据流都使用一个相同的连接，<br>这样比在不同的连接上将有更好的行为和位置优势(同一个位置更便于管理和操作)。</p>
<blockquote>
<p>HTTP2相对于HTTP1.x解决了连接无法复用的问题。所谓的连接复用，就是多个stream流都采用同一Socket<br>进行连接，这些Stream都有一个相同的特征，就是它们的host和port必须是相同的，每一个stream代表一次<br>request请求。通过复用同一个Socket连接，能够显著的减少Socket建立TCP连接时，三次握手的时间。</p>
</blockquote>
<p>StreamAllocation的实例代表这一个使用一个或多个基于一个或多个连接的数据流(说白了就是一个请求的<br>数据流管理类)，这个类提供了基于这些连接资源的释放API：</p>
<p><strong>noNewStreams</strong></p>
<p>noNewStreams方法能够防止一个连接被再次创建一个新的数据流，这个方法一般用在连接的close方法被调<br>用，或者连接与需求不符的情况下。</p>
<p><strong>streamFinished</strong></p>
<p>streamFinished用来释放当前allocation中保存的活跃的数据流。</p>
<blockquote>
<p>在同一时刻，只有一个连接可能是处于活跃状态，所以在创建其他的数据流之前，必须确保已经调用了本方<br>法将活跃的连接关闭掉。</p>
</blockquote>
<p><strong>release</strong></p>
<p>release方法的作用是移除当前连接上的请求(多个Stream)；</p>
<blockquote>
<p>如果当前连接上任然存在一个活跃的数据流，则调用这个方法不会立马释放连接。比如，当一个请求已经<br>结束了，但是，我们还没有使用完response的响应体数据(通过response读取网络文件输出流)。</p>
</blockquote>
<p>上面三种管理连接的方式，在StreamAllocation中对应了三个方法，这三个方法都调用了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>来进行连接的管理。无论是通过哪种方式，都无法单独做到将连接置为空闲的效果。只有在streamFinished<br>为true，即数据流是关闭或者为创建的状态，才能将当前的连接置为空闲状态(Socket也会同时关闭)。</p>
<p><strong>cancel</strong></p>
<p>cancel 方法用来取消掉当前的数据流和连接，支持异步的调用。如果数据流是基于HTTP2协议的，则在<br>调用该方法时，只会关闭该数据流，连接和共享该连接的其他数据流不会受到影响。</p>
<p>如果连接正处于TLS握手阶段(即还没正式建立起来)，调用该方法可能会打断整个连接。</p>
<h6 id="findConnection"><a href="#findConnection" class="headerlink" title="findConnection"></a>findConnection</h6><p>该方法将返回一个持有新的数据流的连接，如果已经存在现成可用的连接，则会直接使用；否则会先创建<br>连接，放入连接池；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout,</span><br><span class="line">    boolean connectionRetryEnabled) throws IOException &#123;</span><br><span class="line">  Route selectedRoute;</span><br><span class="line">  synchronized (connectionPool) &#123;</span><br><span class="line">    if (released) throw new IllegalStateException(&quot;released&quot;);</span><br><span class="line">    if (codec != null) throw new IllegalStateException(&quot;codec != null&quot;);</span><br><span class="line">    if (canceled) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line"></span><br><span class="line">    // 检查是否已经有现成的连接可用</span><br><span class="line">    // 注意这个连接必须是可以创建新的数据流的，即noNewStreams为false</span><br><span class="line">    // Attempt to use an already-allocated connection.</span><br><span class="line">    RealConnection allocatedConnection = this.connection;</span><br><span class="line">    if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) &#123;</span><br><span class="line">      return allocatedConnection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 根据address和Route从连接池中查找是否有现成可用的连接</span><br><span class="line">    // Attempt to get a connection from the pool.</span><br><span class="line">    Internal.instance.get(connectionPool, address, this, null);</span><br><span class="line">    // 如果找到连接，则会调用StreamAllocation的acquire方法，赋给connection变量</span><br><span class="line">    if (connection != null) &#123;</span><br><span class="line">      return connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更换路由</span><br><span class="line">    selectedRoute = route;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 确保更新了路由</span><br><span class="line">  // If we need a route, make one. This is a blocking operation.</span><br><span class="line">  if (selectedRoute == null) &#123;</span><br><span class="line">    selectedRoute = routeSelector.next();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  RealConnection result;</span><br><span class="line">  synchronized (connectionPool) &#123;</span><br><span class="line">    if (canceled) throw new IOException(&quot;Canceled&quot;);</span><br><span class="line"></span><br><span class="line">    // 根据新的路由，从连接池中查找是否有新的连接</span><br><span class="line">    // Now that we have an IP address, make another attempt at getting a connection from the pool.</span><br><span class="line">    // This could match due to connection coalescing.</span><br><span class="line">    Internal.instance.get(connectionPool, address, this, selectedRoute);</span><br><span class="line">    if (connection != null) return connection;</span><br><span class="line"></span><br><span class="line">    // 根据路由，创建一个新的连接，并立刻将其赋给StreamAllocation，这样能够确保我们在异步调用</span><br><span class="line">    // cancel方法时能够直接打断连接进行握手。</span><br><span class="line">    // Create a connection and assign it to this allocation immediately. This makes it possible</span><br><span class="line">    // for an asynchronous cancel() to interrupt the handshake we&apos;re about to do.</span><br><span class="line">    route = selectedRoute;</span><br><span class="line">    refusedStreamCount = 0;</span><br><span class="line">    result = new RealConnection(connectionPool, selectedRoute);</span><br><span class="line">    acquire(result);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 进行TCP连接和TLS握手</span><br><span class="line">  // Do TCP + TLS handshakes. This is a blocking operation.</span><br><span class="line">  result.connect(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">  // 将已建立的连接缓存</span><br><span class="line">  routeDatabase().connected(result.route());</span><br><span class="line"></span><br><span class="line">  Socket socket = null;</span><br><span class="line">  synchronized (connectionPool) &#123;</span><br><span class="line">    // 将连接放到连接池中</span><br><span class="line">    // 该方法最终将调用ConnectionPool的put方法，而put方法在添加连接的同时，会执行其中的</span><br><span class="line">    // cleanupRunnable，清除连接池中保存时间最长的空闲连接</span><br><span class="line">    // Pool the connection.</span><br><span class="line">    Internal.instance.put(connectionPool, result);</span><br><span class="line"></span><br><span class="line">    // 在异步的情况下，如果连接是基于HTTP2协议的，并且有其他的请求已经建立了相同的连接</span><br><span class="line">    // 则复用那个连接，并把当前建立的连接释放掉</span><br><span class="line">    // If another multiplexed connection to the same address was created concurrently, then</span><br><span class="line">    // release this connection and acquire that one.</span><br><span class="line">    // 检查是否是基于HTTP2的连接</span><br><span class="line">    if (result.isMultiplexed()) &#123;</span><br><span class="line">      // 检查是否已经建立相同的连接，相同则把旧连接绑定到当前StreamAllocation，并</span><br><span class="line">      // 释放当前连接，把当前连接的Socket返回</span><br><span class="line">      // 该方法最终调用的是ConnectionPool的deduplicate，而在该方法中，当匹配到相同的</span><br><span class="line">      // 连接时，将回调StreamAllocation的releaseAndAcquire方法进行释放和设置</span><br><span class="line">      socket = Internal.instance.deduplicate(connectionPool, address, this);</span><br><span class="line">      result = connection;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 关闭Socket</span><br><span class="line">  closeQuietly(socket);</span><br><span class="line"></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="releaseAndAcquire"><a href="#releaseAndAcquire" class="headerlink" title="releaseAndAcquire"></a>releaseAndAcquire</h6><p>释放当前Allocation持有的连接，并用传递进来的连接进行代替。在同时有多个HTTP2异步请求发出时，<br>如果发现Allocation新建的连接已经存在了，可以调用该方法，实现线程安全的去重操作；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public Socket releaseAndAcquire(RealConnection newConnection) &#123;</span><br><span class="line">  assert (Thread.holdsLock(connectionPool));</span><br><span class="line">  // StreamAllocation刚创建连接时，该连接中包含的StreamAllocation个数只能是1(即当前实例)</span><br><span class="line">  // 多于1，表明当前StreamAllocation持有的连接不是新建的，已经被其他StreamAllocation持有了</span><br><span class="line">  if (codec != null || connection.allocations.size() != 1) throw new IllegalStateException();</span><br><span class="line"></span><br><span class="line">  // 新连接中只有一个StreamAllocation，所以只需取第一个</span><br><span class="line">  // Release the old connection.</span><br><span class="line">  Reference&lt;StreamAllocation&gt; onlyAllocation = connection.allocations.get(0);</span><br><span class="line"></span><br><span class="line">  // 释放当前StreamAllocation持有的连接</span><br><span class="line">  Socket socket = deallocate(true, false, false);</span><br><span class="line"></span><br><span class="line">  // 将新连接(其实是旧连接，其他StreamAllocation已经持有了)赋给当前StreamAllocation</span><br><span class="line">  // Acquire the new connection.</span><br><span class="line">  this.connection = newConnection;</span><br><span class="line">  // 将当前StreamAllocation交给连接管理(这也是为什么前面的判断多于1会抛异常，旧连接会持有多个</span><br><span class="line">  // StreamAllocation)</span><br><span class="line">  newConnection.allocations.add(onlyAllocation);</span><br><span class="line"></span><br><span class="line">  return socket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h6><p>deallocate方法用来把当前StreamAllocation持有的连接释放掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private Socket deallocate(boolean noNewStreams, boolean released, boolean streamFinished) &#123;</span><br><span class="line">  assert (Thread.holdsLock(connectionPool));</span><br><span class="line"></span><br><span class="line">  // 结束数据流传输</span><br><span class="line">  if (streamFinished) &#123;</span><br><span class="line">    this.codec = null;</span><br><span class="line">  &#125;</span><br><span class="line">  if (released) &#123;</span><br><span class="line">    this.released = true;</span><br><span class="line">  &#125;</span><br><span class="line">  Socket socket = null;</span><br><span class="line">  if (connection != null) &#123;</span><br><span class="line">    // 标记连接不能再创建新的数据流</span><br><span class="line">    if (noNewStreams) &#123;</span><br><span class="line">      connection.noNewStreams = true;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果当前StreamAllocation不存在活跃的数据流，并且可以释放或者不能再创建新数据流</span><br><span class="line">    if (this.codec == null &amp;&amp; (this.released || connection.noNewStreams)) &#123;</span><br><span class="line">      // 将当前StreamAllocation从连接中移除</span><br><span class="line">      release(connection);</span><br><span class="line"></span><br><span class="line">      // 如果当前StreamAllocation持有的连接没有被其他的StreamAllocation持有</span><br><span class="line">      // 则尝试释放掉该连接</span><br><span class="line">      if (connection.allocations.isEmpty()) &#123;</span><br><span class="line">        connection.idleAtNanos = System.nanoTime();</span><br><span class="line">        // 将连接置为空闲状态</span><br><span class="line">        // 连接池默认允许5个空闲的连接存在</span><br><span class="line">        // 如果自定义连接池，空闲连接个数设置为0，则连接置为空闲后，会立刻被从连接池中移除，</span><br><span class="line">        // 如果连接被移除，则移除的连接的Socket会被返回，进行关闭操作</span><br><span class="line"></span><br><span class="line">        // 默认情况下，当我们在findConnection中添加新的连接进入连接池时，就会推动连接池清除</span><br><span class="line">        // 空闲的连接</span><br><span class="line">        if (Internal.instance.connectionBecameIdle(connectionPool, connection)) &#123;</span><br><span class="line">          socket = connection.socket();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      connection = null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return socket;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="findHealthyConnection"><a href="#findHealthyConnection" class="headerlink" title="findHealthyConnection"></a>findHealthyConnection</h6><p>获取一个可以使用的连接；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private RealConnection findHealthyConnection(int connectTimeout, int readTimeout,</span><br><span class="line">    int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks)</span><br><span class="line">    throws IOException &#123;</span><br><span class="line">  // 循环获取一个有效的连接</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    // 获取一个连接，可能是从缓存池中获取，也可能是新建的</span><br><span class="line">    RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout,</span><br><span class="line">        connectionRetryEnabled);</span><br><span class="line"></span><br><span class="line">    // 如果是新建的连接，则直接跳过连接的健康检查</span><br><span class="line">    // If this is a brand new connection, we can skip the extensive health checks.</span><br><span class="line">    synchronized (connectionPool) &#123;</span><br><span class="line">      if (candidate.successCount == 0) &#123;</span><br><span class="line">        return candidate;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果是旧连接，检查连接是否还有效，无效则将连接的noNewStreams置为false(不能再创建新连接)</span><br><span class="line">    // 再次循环获取连接</span><br><span class="line">    // Do a (potentially slow) check to confirm that the pooled connection is still good. If it</span><br><span class="line">    // isn&apos;t, take it out of the pool and start again.</span><br><span class="line">    if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123;</span><br><span class="line">      noNewStreams();</span><br><span class="line">      continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return candidate;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="noNewStreams"><a href="#noNewStreams" class="headerlink" title="noNewStreams"></a>noNewStreams</h6><p>这个方法的主要作用是设置当前的StreamAllocation的连接不能再创建新的数据流；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void noNewStreams() &#123;</span><br><span class="line">  Socket socket;</span><br><span class="line">  synchronized (connectionPool) &#123;</span><br><span class="line">    // 这里只有参数1 noNewStreams为true，大多数情况下只是起到让连接不能再创建数据流的作用</span><br><span class="line">    // 当StreamAllocation没有数据流或者处于释放状态下，则会关闭连接</span><br><span class="line">    socket = deallocate(true, false, false);</span><br><span class="line">  &#125;</span><br><span class="line">  closeQuietly(socket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="newStream"><a href="#newStream" class="headerlink" title="newStream"></a>newStream</h6><p>创建一个新的数据流；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public HttpCodec newStream(OkHttpClient client, boolean doExtensiveHealthChecks) &#123;</span><br><span class="line">  int connectTimeout = client.connectTimeoutMillis();</span><br><span class="line">  int readTimeout = client.readTimeoutMillis();</span><br><span class="line">  int writeTimeout = client.writeTimeoutMillis();</span><br><span class="line">  boolean connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">  try &#123;</span><br><span class="line">    // 获取一个健康可用的连接(可能是新建的，也可能是从连接池中获取的)</span><br><span class="line">    RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">        writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line"></span><br><span class="line">    // 在连接上创建一个新的数据流，可能是基于HTTP1.x协议的Http1Codec</span><br><span class="line">    // 也可能是基于HTTP2协议的Http2Codec</span><br><span class="line">    // 如果是基于HTTP1.x协议的，必须确保连接是新的连接，只有新连接的noNewStream才为false</span><br><span class="line">    // 而HTTP2.x则可以进行连接的复用，所以可以是旧连接，但同样noNewStream必须为false</span><br><span class="line">    HttpCodec resultCodec = resultConnection.newCodec(client, this);</span><br><span class="line"></span><br><span class="line">    synchronized (connectionPool) &#123;</span><br><span class="line">      codec = resultCodec;</span><br><span class="line">      return resultCodec;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; catch (IOException e) &#123;</span><br><span class="line">    throw new RouteException(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ConnectInterceptor-intercept"><a href="#ConnectInterceptor-intercept" class="headerlink" title="ConnectInterceptor.intercept"></a>ConnectInterceptor.intercept</h5><p>至此，ConnectInterceptor的intercept方法的流程也就很明确了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public final class ConnectInterceptor implements Interceptor &#123;</span><br><span class="line">  public final OkHttpClient client;</span><br><span class="line"></span><br><span class="line">  public ConnectInterceptor(OkHttpClient client) &#123;</span><br><span class="line">    this.client = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    // 获取从RetryAndFollowUpInterceptor中就已经创建的StreamAllocation</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    // 对于非Get的请求，需要对连接进行健康检查，检查是否可用</span><br><span class="line">    // We need the network to satisfy this request. Possibly for validating a conditional GET.</span><br><span class="line">    boolean doExtensiveHealthChecks = !request.method().equals(&quot;GET&quot;);</span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    return realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>拿到在RetryAndFollowUpInterceptor中创建的StreamAllocation实例(在这里才算是第一使用了<br>StreamAllocation)，通过StreamAllocation创建新的数据流，获取可用的连接(连接也可能是在创建<br>新数据流的过程中创建的，也可能是从连接池中拿的)，传递给RealInterceptorChain的proceed方法，<br>推动拦截链进入系统拦截器的最后一个环节——CallServerInterceptor。</p>
<p><img src="/images/connectinterceptor转换关系.png" alt="image"></p>
<blockquote>
<p>每一个请求都对应这一个StreamAllocation、一个RealConnection、一个HttpCodec；<br></p>
</blockquote>
<p><img src="/images/StreamAllocation与Connection和httpcodec关系.png" alt="image"></p>
<blockquote>
<p>在StreamAllocation中，在创建新的数据流时，会从连接池中查找是否有可复用的连接，没有才会创建<br>新的连接，并把新的连接放入到连接池中，在放入连接池的同时，连接池会把当前空闲最久的连接的给移除掉；</p>
</blockquote>
<blockquote>
<p>在StreamAllocation中，根据Address和Route信息，可能从缓存池中获取出一个连接RealConnection，<br>也可能是新建一个RealConnection(创建后会把RealConnection放入到ConnectionPool中)，最终的目的<br>是将Request转化为一个对应数据流(HttpCodec)，用来与服务端进行数据通信.</p>
</blockquote>
<p><img src="/images/StreamAllocation与RealConnection.png" alt="image"></p>
<blockquote>
<p>对于基于HTTP1.x协议的连接，一个连接只能同时被一个请求使用，也就是说一个RealConnection中<br>同时只会存在一个SteamAllocation，而一个SteamAllocation对应一个数据流，当同时有多个请求对<br>同一个地址路由发起请求时，需要建立多个连接，所以Http1.x效率是低下的。(这并不以为着每次请求都<br>需要进行三次握手，因为有连接池的存在，对于同一个地址路由的请求，能够复用连接，但这种方式，拿到<br>缓存的连接可能会失效！)</p>
</blockquote>
<blockquote>
<p>HTTP1.x协议中有一种建立管道通信方式的长连接，这种方式虽然也能够省去建立连接时的握手时间，并且<br>不像缓存一样，连接会失效，但这种方式会一直占用着连接，对于通信不频繁的情况，将会浪费资源。</p>
</blockquote>
<blockquote>
<p>HTTP2协议的连接，支持连接复用，也就是说，一个连接可以被多个请求同时使用，对应的就是一个<br>RealConnection可以对应(保存)多个StreamAllocation。一个连接中将会同时有多个StreamAllocation<br>在进行数据通信(实际上，虽然实现了连接复用，但多个数据流并不是在通道中并发传输的，而是需要排队<br>顺序通过连接通道，到达服务端后，根据序号再各自组成完整数据请求)；</p>
</blockquote>
<h4 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h4><p>到此拦截器，我们已经与服务端建立了连接，接下来在CallServerInterceptor中进行了Stream数据流的<br>沟通；</p>
<h5 id="intercept"><a href="#intercept" class="headerlink" title="intercept"></a>intercept</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">@Override public Response intercept(Chain chain) throws IOException &#123;</span><br><span class="line">  RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">  HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">  StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">  RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">  Request request = realChain.request();</span><br><span class="line"></span><br><span class="line">  long sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">  // 向服务端写入请求头数据</span><br><span class="line">  httpCodec.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">  Response.Builder responseBuilder = null;</span><br><span class="line">  // 如果请求中带有请求体，并且请求方式是允许带有请求体的</span><br><span class="line">  if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123;</span><br><span class="line">    // 如果客户端需要向服务端上传大数据(比如上传文件)，则会在请求头中写入&quot;Expect: 100-continue&quot;</span><br><span class="line">    // 如果服务端能够处理该请求，则响应100，否则响应4xx。</span><br><span class="line">    // 如果服务端在timeout时间内始终没有响应，则客户端会立即进行上传，服务端在收到上传的数据</span><br><span class="line">    // 后，并且是能够处理的，则会省去响应100的步骤</span><br><span class="line">    // If there&apos;s a &quot;Expect: 100-continue&quot; header on the request, wait for a &quot;HTTP/1.1 100</span><br><span class="line">    // Continue&quot; response before transmitting the request body. If we don&apos;t get that, return what</span><br><span class="line">    // we did get (such as a 4xx response) without ever transmitting the request body.</span><br><span class="line">    if (&quot;100-continue&quot;.equalsIgnoreCase(request.header(&quot;Expect&quot;))) &#123;</span><br><span class="line">      httpCodec.flushRequest();</span><br><span class="line">      // 读取服务端的响应response，如果服务端响应100，表明请求还在继续，后续要向服务端写请求体，此处返回null</span><br><span class="line">      // 否则本次请求结束。注意，请求结束并不意味着数据流传输结束，只是不能再创建新的数据流(http2)</span><br><span class="line">      responseBuilder = httpCodec.readResponseHeaders(true);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (responseBuilder == null) &#123;</span><br><span class="line">      // 开始向服务端写入请求体</span><br><span class="line">      // Write the request body if the &quot;Expect: 100-continue&quot; expectation was met.</span><br><span class="line">      Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">      BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">      request.body().writeTo(bufferedRequestBody);</span><br><span class="line">      bufferedRequestBody.close();</span><br><span class="line">    &#125; else if (!connection.isMultiplexed()) &#123;</span><br><span class="line">      // 如果不是HTTP2协议的连接，需要防止该连接上被创建新的数据流(即连接被重用)，此时可能正</span><br><span class="line">      // 处于数据流传输的过程。</span><br><span class="line">      // If the &quot;Expect: 100-continue&quot; expectation wasn&apos;t met, prevent the HTTP/1 connection from</span><br><span class="line">      // being reused. Otherwise we&apos;re still obligated to transmit the request body to leave the</span><br><span class="line">      // connection in a consistent state.</span><br><span class="line">      streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 请求结束</span><br><span class="line">  httpCodec.finishRequest();</span><br><span class="line"></span><br><span class="line">  // 读取响应头</span><br><span class="line">  if (responseBuilder == null) &#123;</span><br><span class="line">    responseBuilder = httpCodec.readResponseHeaders(false);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 构造完整的响应头，方便后续的拦截器处理</span><br><span class="line">  Response response = responseBuilder</span><br><span class="line">      .request(request)</span><br><span class="line">      .handshake(streamAllocation.connection().handshake())</span><br><span class="line">      .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  int code = response.code();</span><br><span class="line">  // 基于WebSocket协议连接，或者服务端希望客户端切换新的请求协议，再请求，则构建一个空的响应体</span><br><span class="line">  // 给后续的拦截器</span><br><span class="line">  if (forWebSocket &amp;&amp; code == 101) &#123;</span><br><span class="line">    // Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(Util.EMPTY_RESPONSE)</span><br><span class="line">        .build();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 读取响应体</span><br><span class="line">    response = response.newBuilder()</span><br><span class="line">        .body(httpCodec.openResponseBody(response))</span><br><span class="line">        .build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 客户端或服务端希望关闭连接</span><br><span class="line">  if (&quot;close&quot;.equalsIgnoreCase(response.request().header(&quot;Connection&quot;))</span><br><span class="line">      || &quot;close&quot;.equalsIgnoreCase(response.header(&quot;Connection&quot;))) &#123;</span><br><span class="line">    streamAllocation.noNewStreams();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 204/205表示服务端成功处理了请求，并且不返回任何响应</span><br><span class="line">  // 如果带有响应体，则抛出协议异常</span><br><span class="line">  if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123;</span><br><span class="line">    throw new ProtocolException(</span><br><span class="line">        &quot;HTTP &quot; + code + &quot; had non-zero Content-Length: &quot; + response.body().contentLength());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HttpCodec可以认为是http请求中的解码器，在与服务的那成功建立连接后，利用其向服务端写入请求和读<br>取响应数据，其根据HTTP协议的不同，分别采用HttpCodec1(HTTP1.x)和HttpCodec2(HTTP2)来进行处理；</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/OkHttp/" rel="tag"># OkHttp</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/08/14/Android/OkHttp/Okhttp源码分析一/" rel="next" title="OkHttp源码分析(一)">
                <i class="fa fa-chevron-left"></i> OkHttp源码分析(一)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/26/NDK/C/IO操作/" rel="prev" title="IO操作">
                IO操作 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">黄声焕</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">categories</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">tags</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#拦截器"><span class="nav-number">1.</span> <span class="nav-text">拦截器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RealInterceptorChain"><span class="nav-number">2.</span> <span class="nav-text">RealInterceptorChain</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RetryAndFollowUpInterceptor"><span class="nav-number">3.</span> <span class="nav-text">RetryAndFollowUpInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BridgeInterceptor"><span class="nav-number">4.</span> <span class="nav-text">BridgeInterceptor</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CacheInterceptor"><span class="nav-number">5.</span> <span class="nav-text">CacheInterceptor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CacheStrategy"><span class="nav-number">5.1.</span> <span class="nav-text">CacheStrategy</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CacheInterceptor-1"><span class="nav-number">5.2.</span> <span class="nav-text">CacheInterceptor</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ConnectInterceptor"><span class="nav-number">6.</span> <span class="nav-text">ConnectInterceptor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RealConnection"><span class="nav-number">6.1.</span> <span class="nav-text">RealConnection</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#connectSocket"><span class="nav-number">6.1.1.</span> <span class="nav-text">connectSocket</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#createTunnel"><span class="nav-number">6.1.2.</span> <span class="nav-text">createTunnel</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#connectTunnel"><span class="nav-number">6.1.3.</span> <span class="nav-text">connectTunnel</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#establishProtocol"><span class="nav-number">6.1.4.</span> <span class="nav-text">establishProtocol</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#connect"><span class="nav-number">6.1.5.</span> <span class="nav-text">connect</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#StreamAllocation"><span class="nav-number">6.2.</span> <span class="nav-text">StreamAllocation</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#findConnection"><span class="nav-number">6.2.1.</span> <span class="nav-text">findConnection</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#releaseAndAcquire"><span class="nav-number">6.2.2.</span> <span class="nav-text">releaseAndAcquire</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#deallocate"><span class="nav-number">6.2.3.</span> <span class="nav-text">deallocate</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#findHealthyConnection"><span class="nav-number">6.2.4.</span> <span class="nav-text">findHealthyConnection</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#noNewStreams"><span class="nav-number">6.2.5.</span> <span class="nav-text">noNewStreams</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#newStream"><span class="nav-number">6.2.6.</span> <span class="nav-text">newStream</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ConnectInterceptor-intercept"><span class="nav-number">6.3.</span> <span class="nav-text">ConnectInterceptor.intercept</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CallServerInterceptor"><span class="nav-number">7.</span> <span class="nav-text">CallServerInterceptor</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#intercept"><span class="nav-number">7.1.</span> <span class="nav-text">intercept</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">黄声焕</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Gemini</a> v6.3.0</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv" title="Total Visitors">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="site-pv" title="Total Views">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
